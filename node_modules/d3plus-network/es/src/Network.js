/**
    @external Viz
    @see https://github.com/d3plus/d3plus-viz#Viz
*/

import {extent, mean, min, merge} from "d3-array";
import {nest} from "d3-collection";
// import {forceSimulation} from "d3-force";
import * as scales from "d3-scale";
import {zoomTransform} from "d3-zoom";

import {accessor, assign, configPrep, constant, elem} from "d3plus-common";
import * as shapes from "d3plus-shape";
import {dataLoad as load, Viz} from "d3plus-viz";

/**
    @class Network
    @extends external:Viz
    @desc Creates a network visualization based on a defined set of nodes and edges. [Click here](http://d3plus.org/examples/d3plus-network/getting-started/) for help getting started using the Network class.
*/
var Network = (function (Viz) {
  function Network() {
    var this$1 = this;


    Viz.call(this);
    this._labelCutoff = 100;
    this._links = [];
    this._noDataMessage = false;
    this._nodes = [];
    this._on["click.shape"] = function (d, i) {

      this$1._tooltipClass.data([]).render();

      if (this$1._hover && this$1._drawDepth >= this$1._groupBy.length - 1) {

        if (this$1._focus && this$1._focus === d.id) {

          this$1.active(false);
          this$1._on.mouseenter.bind(this$1)(d, i);

          this$1._focus = undefined;
          this$1._zoomToBounds(null);

        }
        else {

          this$1.hover(false);

          var id = this$1._nodeGroupBy && this$1._nodeGroupBy[this$1._drawDepth](d, i) ? this$1._nodeGroupBy[this$1._drawDepth](d, i) : this$1._id(d, i),
                links = this$1._linkLookup[id],
                node = this$1._nodeLookup[id];

          var filterIds = [node.id];
          var xDomain = [node.x - node.r, node.x + node.r],
              yDomain = [node.y - node.r, node.y + node.r];

          links.forEach(function (l) {
            filterIds.push(l.id);
            if (l.x - l.r < xDomain[0]) { xDomain[0] = l.x - l.r; }
            if (l.x + l.r > xDomain[1]) { xDomain[1] = l.x + l.r; }
            if (l.y - l.r < yDomain[0]) { yDomain[0] = l.y - l.r; }
            if (l.y + l.r > yDomain[1]) { yDomain[1] = l.y + l.r; }
          });

          this$1.active(function (h, x) {
            if (h.source && h.target) { return h.source.id === node.id || h.target.id === node.id; }
            else { return filterIds.includes(this$1._ids(h, x)[this$1._drawDepth]); }
          });

          this$1._focus = d.id;
          var t = zoomTransform(this$1._container.node());
          xDomain = xDomain.map(function (d) { return d * t.k + t.x; });
          yDomain = yDomain.map(function (d) { return d * t.k + t.y; });
          this$1._zoomToBounds([[xDomain[0], yDomain[0]], [xDomain[1], yDomain[1]]]);

        }

      }

    };
    this._on["click.legend"] = function (d, i) {

      var ids = this$1._id(d);
      var id = this$1._ids(d);
      id = id[id.length - 1];

      if (this$1._hover && this$1._drawDepth >= this$1._groupBy.length - 1) {

        if (this$1._focus && this$1._focus === ids) {

          this$1.active(false);
          this$1._on.mouseenter.bind(this$1)(d, i);

          this$1._focus = undefined;
          this$1._zoomToBounds(null);

        }
        else {

          this$1.hover(false);

          var nodes = ids.map(function (id) { return this$1._nodeLookup[id]; });

          var filterIds = [id];
          var xDomain = [nodes[0].x - nodes[0].r, nodes[0].x + nodes[0].r],
              yDomain = [nodes[0].y - nodes[0].r, nodes[0].y + nodes[0].r];

          nodes.forEach(function (l) {
            filterIds.push(l.id);
            if (l.x - l.r < xDomain[0]) { xDomain[0] = l.x - l.r; }
            if (l.x + l.r > xDomain[1]) { xDomain[1] = l.x + l.r; }
            if (l.y - l.r < yDomain[0]) { yDomain[0] = l.y - l.r; }
            if (l.y + l.r > yDomain[1]) { yDomain[1] = l.y + l.r; }
          });

          this$1.active(function (h, x) {
            if (h.source && h.target) { return filterIds.includes(h.source.id) && filterIds.includes(h.target.id); }
            else {
              var myIds = this$1._ids(h, x);
              return filterIds.includes(myIds[myIds.length - 1]);
            }
          });

          this$1._focus = ids;
          var t = zoomTransform(this$1._container.node());
          xDomain = xDomain.map(function (d) { return d * t.k + t.x; });
          yDomain = yDomain.map(function (d) { return d * t.k + t.y; });
          this$1._zoomToBounds([[xDomain[0], yDomain[0]], [xDomain[1], yDomain[1]]]);

        }

        this$1._on["mousemove.legend"].bind(this$1)(d, i);

      }

    };
    this._sizeMin = 5;
    this._sizeScale = "sqrt";
    this._shape = constant("Circle");
    this._shapeConfig = assign(this._shapeConfig, {
      ariaLabel: function (d, i) {
        var validSize = this$1._size ? (", " + (this$1._size(d, i))) : "";
        return ("" + (this$1._drawLabel(d, i)) + validSize + ".");
      },
      labelConfig: {
        duration: 0,
        fontMin: 1,
        fontResize: true,
        labelPadding: 0,
        textAnchor: "middle",
        verticalAlign: "middle"
      },
      Path: {
        fill: "none",
        label: false,
        stroke: "#eee",
        strokeWidth: 1
      }
    });
    this._x = accessor("x");
    this._y = accessor("y");

    this._zoom = true;

  }

  if ( Viz ) Network.__proto__ = Viz;
  Network.prototype = Object.create( Viz && Viz.prototype );
  Network.prototype.constructor = Network;

  /**
      Extends the draw behavior of the abstract Viz class.
      @private
  */
  Network.prototype._draw = function _draw (callback) {
    var this$1 = this;


    Viz.prototype._draw.call(this, callback);

    var height = this._height - this._margin.top - this._margin.bottom,
          transform = "translate(" + (this._margin.left) + ", " + (this._margin.top) + ")",
          transition = this._transition,
          width = this._width - this._margin.left - this._margin.right;

    var data = this._filteredData.reduce(function (obj, d, i) {
      obj[this$1._id(d, i)] = d;
      return obj;
    }, {});

    var nodes = this._nodes.reduce(function (obj, d, i) {
      obj[this$1._nodeGroupBy ? this$1._nodeGroupBy[this$1._drawDepth](d, i) : this$1._id(d, i)] = d;
      return obj;
    }, {});

    nodes = Array.from(new Set(Object.keys(data).concat(Object.keys(nodes)))).map(function (id, i) {

      var d = data[id],
            n = nodes[id];

      if (n === undefined) { return false; }

      return {
        __d3plus__: true,
        data: d || n,
        i: i, id: id,
        fx: d !== undefined && this$1._x(d) !== undefined ? this$1._x(d) : this$1._x(n),
        fy: d !== undefined && this$1._y(d) !== undefined ? this$1._y(d) : this$1._y(n),
        node: n,
        r: this$1._size ? d !== undefined && this$1._size(d) !== undefined ? this$1._size(d) : this$1._size(n) : this$1._sizeMin,
        shape: d !== undefined && this$1._shape(d) !== undefined ? this$1._shape(d) : this$1._shape(n)
      };

    }).filter(function (n) { return n; });

    var xExtent = extent(nodes.map(function (n) { return n.fx; })),
          yExtent = extent(nodes.map(function (n) { return n.fy; }));

    var x = scales.scaleLinear().domain(xExtent).range([0, width]),
          y = scales.scaleLinear().domain(yExtent).range([0, height]);

    var nodeRatio = (xExtent[1] - xExtent[0]) / (yExtent[1] - yExtent[0]),
          screenRatio = width / height;

    if (nodeRatio > screenRatio) {
      var h = height * screenRatio / nodeRatio;
      y.range([(height - h) / 2, height - (height - h) / 2]);
    }
    else {
      var w = width * nodeRatio / screenRatio;
      x.range([(width - w) / 2, width - (width - w) / 2]);
    }

    nodes.forEach(function (n) {
      n.x = x(n.fx);
      n.y = y(n.fy);
    });

    var rExtent = extent(nodes.map(function (n) { return n.r; }));
    var rMax = this._sizeMax || min(
      merge(nodes
        .map(function (n1) { return nodes
          .map(function (n2) { return n1 === n2 ? null : shapes.pointDistance([n1.x, n1.y], [n2.x, n2.y]); }); }
        )
      )
    ) / 2;

    var r = scales[("scale" + (this._sizeScale.charAt(0).toUpperCase()) + (this._sizeScale.slice(1)))]()
                .domain(rExtent).range([rExtent[0] === rExtent[1] ? rMax : min([rMax / 2, this._sizeMin]), rMax]),
          xDomain = x.domain(),
          yDomain = y.domain();

    var xOldSize = xDomain[1] - xDomain[0],
          yOldSize = yDomain[1] - yDomain[0];

    nodes.forEach(function (n) {
      var size = r(n.r);
      if (xDomain[0] > x.invert(n.x - size)) { xDomain[0] = x.invert(n.x - size); }
      if (xDomain[1] < x.invert(n.x + size)) { xDomain[1] = x.invert(n.x + size); }
      if (yDomain[0] > y.invert(n.y - size)) { yDomain[0] = y.invert(n.y - size); }
      if (yDomain[1] < y.invert(n.y + size)) { yDomain[1] = y.invert(n.y + size); }
    });

    var xNewSize = xDomain[1] - xDomain[0],
          yNewSize = yDomain[1] - yDomain[0];

    rMax *= min([xOldSize / xNewSize, yOldSize / yNewSize]);
    r.range([rExtent[0] === rExtent[1] ? rMax : min([rMax / 2, this._sizeMin]), rMax]);
    x.domain(xDomain);
    y.domain(yDomain);

    nodes.forEach(function (n) {
      n.x = x(n.fx);
      n.fx = n.x;
      n.y = y(n.fy);
      n.fy = n.y;
      n.r = r(n.r);
      n.width = n.r * 2;
      n.height = n.r * 2;
    });

    var nodeLookup = this._nodeLookup = nodes.reduce(function (obj, d) {
      obj[d.id] = d;
      return obj;
    }, {});

    // forceSimulation(nodes)
    //   .on("tick", () => this._shapes.forEach(s => s.render()));

    var nodeIndices = nodes.map(function (n) { return n.node; });
    var links = this._links.map(function (l) { return ({
      source: typeof l.source === "number"
        ? nodes[nodeIndices.indexOf(this$1._nodes[l.source])]
        : nodeLookup[l.source.id],
      target: typeof l.target === "number"
        ? nodes[nodeIndices.indexOf(this$1._nodes[l.target])]
        : nodeLookup[l.target.id]
    }); });

    this._linkLookup = links.reduce(function (obj, d) {
      if (!obj[d.source.id]) { obj[d.source.id] = []; }
      obj[d.source.id].push(d.target);
      if (!obj[d.target.id]) { obj[d.target.id] = []; }
      obj[d.target.id].push(d.source);
      return obj;
    }, {});

    this._container = this._select.selectAll("svg.d3plus-network").data([0]);

    this._container = this._container.enter().append("svg")
        .attr("class", "d3plus-network")
        .attr("opacity", 0)
        .attr("width", width)
        .attr("height", height)
        .attr("x", this._margin.left)
        .attr("y", this._margin.top)
        .style("background-color", "transparent")
      .merge(this._container);

    this._container.transition(this._transition)
      .attr("opacity", 1)
      .attr("width", width)
      .attr("height", height)
      .attr("x", this._margin.left)
      .attr("y", this._margin.top);

    var hitArea = this._container.selectAll("rect.d3plus-network-hitArea").data([0]);
    hitArea.enter().append("rect")
        .attr("class", "d3plus-network-hitArea")
      .merge(hitArea)
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "transparent")
        .on("click", function () {
          if (this$1._focus) {
            this$1.active(false);
            this$1._focus = undefined;
            this$1._zoomToBounds(null);
          }
        });

    this._zoomGroup = this._container.selectAll("g.d3plus-network-zoomGroup").data([0]);
    var parent = this._zoomGroup = this._zoomGroup.enter().append("g")
        .attr("class", "d3plus-network-zoomGroup")
      .merge(this._zoomGroup);

    this._shapes.push(new shapes.Path()
      .config(this._shapeConfig)
      .config(this._shapeConfig.Path)
      .d(function (d) { return ("M" + (d.source.x) + "," + (d.source.y) + " " + (d.target.x) + "," + (d.target.y)); })
      .data(links)
      .select(elem("g.d3plus-network-links", {parent: parent, transition: transition, enter: {transform: transform}, update: {transform: transform}}).node())
      .render());

    var shapeConfig = {
      label: function (d) { return nodes.length <= this$1._labelCutoff || (this$1._hover && this$1._hover(d) || this$1._active && this$1._active(d)) ? this$1._drawLabel(d.data || d.node, d.i) : false; },
      select: elem("g.d3plus-network-nodes", {parent: parent, transition: transition, enter: {transform: transform}, update: {transform: transform}}).node()
    };

    nest().key(function (d) { return d.shape; }).entries(nodes).forEach(function (d) {
      this$1._shapes.push(new shapes[d.key]()
        .config(configPrep.bind(this$1)(this$1._shapeConfig, "shape", d.key))
        .config(shapeConfig)
        .config(shapeConfig[d.key] || {})
        .data(d.values)
        .render());
    });

    return this;

  };

  /**
      @memberof Network
      @desc Defines the maximum number of nodes that allow all labels to be shown. When the number of nodes is over this amount, labels will only be shown on hover and click.
      @param {Number} *value* = 100
      @chainable
  */
  Network.prototype.labelCutoff = function labelCutoff (_) {
    return arguments.length ? (this._labelCutoff = _, this) : this._labelCutoff;
  };

  /**
      @memberof Network
      @desc A predefined *Array* of edges that connect each object passed to the [node](#Network.node) method. The `source` and `target` keys in each link need to map to the nodes in one of three ways:
1. The index of the node in the nodes array (as in [this](http://d3plus.org/examples/d3plus-network/getting-started/) example).
2. The actual node *Object* itself.
3. A *String* value matching the `id` of the node.

The value passed should either be an *Array* of data or a *String* representing a filepath or URL to be loaded. An optional formatting function can be passed as a second argument to this method. This custom function will be passed the data that has been loaded, as long as there are no errors. This function should return the final links *Array*.
      @param {Array|String} *links* = []
      @param {Function} [*formatter*]
      @chainable
  */
  Network.prototype.links = function links (_, f) {
    if (arguments.length) {
      var prev = this._queue.find(function (q) { return q[3] === "links"; });
      var d = [load.bind(this), _, f, "links"];
      if (prev) { this._queue[this._queue.indexOf(prev)] = d; }
      else { this._queue.push(d); }
      return this;
    }
    return this._links;
  };

  /**
      @memberof Network
      @desc If *value* is specified, sets the node group accessor(s) to the specified string, function, or array of values and returns the current class instance. This method overrides the default .groupBy() function from being used with the data passed to .nodes(). If *value* is not specified, returns the current node group accessor.
      @param {String|Function|Array} [*value* = undefined]
      @chainable
  */
  Network.prototype.nodeGroupBy = function nodeGroupBy (_) {
    var this$1 = this;

    if (!arguments.length) { return this._nodeGroupBy; }
    if (!(_ instanceof Array)) { _ = [_]; }
    return this._nodeGroupBy = _.map(function (k) {
      if (typeof k === "function") { return k; }
      else {
        if (!this$1._aggs[k]) {
          this$1._aggs[k] = function (a) {
            var v = Array.from(new Set(a));
            return v.length === 1 ? v[0] : v;
          };
        }
        return accessor(k);
      }
    }), this;
  };

  /**
      @memberof Network
      @desc The list of nodes to be used for drawing the network. The value passed should either be an *Array* of data or a *String* representing a filepath or URL to be loaded.

Additionally, a custom formatting function can be passed as a second argument to this method. This custom function will be passed the data that has been loaded, as long as there are no errors. This function should return the final node *Array*.
      @param {Array|String} *nodes* = []
      @param {Function} [*formatter*]
      @chainable
  */
  Network.prototype.nodes = function nodes (_, f) {
    if (arguments.length) {
      var prev = this._queue.find(function (q) { return q[3] === "nodes"; });
      var d = [load.bind(this), _, f, "nodes"];
      if (prev) { this._queue[this._queue.indexOf(prev)] = d; }
      else { this._queue.push(d); }
      return this;
    }
    return this._nodes;
  };

  /**
      @memberof Network
      @desc If *value* is specified, sets the size accessor to the specified function or data key and returns the current class instance. If *value* is not specified, returns the current size accessor.
      @param {Function|String} [*value*]
      @chainable
  */
  Network.prototype.size = function size (_) {
    return arguments.length ? (this._size = typeof _ === "function" || !_ ? _ : accessor(_), this) : this._size;
  };

  /**
      @memberof Network
      @desc If *value* is specified, sets the size scale maximum to the specified number and returns the current class instance. If *value* is not specified, returns the current size scale maximum. By default, the maximum size is determined by half the distance of the two closest nodes.
      @param {Number} [*value*]
      @chainable
  */
  Network.prototype.sizeMax = function sizeMax (_) {
    return arguments.length ? (this._sizeMax = _, this) : this._sizeMax;
  };

  /**
      @memberof Network
      @desc If *value* is specified, sets the size scale minimum to the specified number and returns the current class instance. If *value* is not specified, returns the current size scale minimum.
      @param {Number} [*value* = 5]
      @chainable
  */
  Network.prototype.sizeMin = function sizeMin (_) {
    return arguments.length ? (this._sizeMin = _, this) : this._sizeMin;
  };

  /**
      @memberof Network
      @desc If *value* is specified, sets the size scale to the specified string and returns the current class instance. If *value* is not specified, returns the current size scale.
      @param {String} [*value* = "sqrt"]
      @chainable
  */
  Network.prototype.sizeScale = function sizeScale (_) {
    return arguments.length ? (this._sizeScale = _, this) : this._sizeScale;
  };

  /**
      @memberof Network
      @desc If *value* is specified, sets the x accessor to the specified function or string matching a key in the data and returns the current class instance. The data passed to .data() takes priority over the .nodes() data array. If *value* is not specified, returns the current x accessor. By default, the x and y positions are determined dynamically based on default force layout properties.
      @param {Function|String} [*value*]
      @chainable
  */
  Network.prototype.x = function x (_) {
    if (arguments.length) {
      if (typeof _ === "function") { this._x = _; }
      else {
        this._x = accessor(_);
        if (!this._aggs[_]) { this._aggs[_] = function (a) { return mean(a); }; }
      }
      return this;
    }
    else { return this._x; }
  };

  /**
      @memberof Network
      @desc If *value* is specified, sets the y accessor to the specified function or string matching a key in the data and returns the current class instance. The data passed to .data() takes priority over the .nodes() data array. If *value* is not specified, returns the current y accessor. By default, the x and y positions are determined dynamically based on default force layout properties.
      @param {Function|String} [*value*]
      @chainable
  */
  Network.prototype.y = function y (_) {
    if (arguments.length) {
      if (typeof _ === "function") { this._y = _; }
      else {
        this._y = accessor(_);
        if (!this._aggs[_]) { this._aggs[_] = function (a) { return mean(a); }; }
      }
      return this;
    }
    else { return this._y; }
  };

  return Network;
}(Viz));

export default Network;

//# sourceMappingURL=Network.js.map