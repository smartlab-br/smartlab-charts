/**
    @external Viz
    @see https://github.com/d3plus/d3plus-viz#Viz
*/

import {extent, max, min} from "d3-array";
import {nest} from "d3-collection";
import * as scales from "d3-scale";

import {accessor, assign, configPrep, constant, elem} from "d3plus-common";
import {colorLegible} from "d3plus-color";
import * as shapes from "d3plus-shape";
import {dataLoad as load, Viz} from "d3plus-viz";

/**
    @class Rings
    @extends external:Viz
    @desc Creates a ring visualization based on a defined set of nodes and edges. [Click here](http://d3plus.org/examples/d3plus-network/simple-rings/) for help getting started using the Rings class.
*/
var Rings = (function (Viz) {
  function Rings() {
    var this$1 = this;


    Viz.call(this);
    this._labelCutoff = 100;
    this._links = [];
    this._noDataMessage = false;
    this._nodes = [];
    this._on.mouseenter = function () {};
    this._on["mouseleave.shape"] = function () {
      this$1.hover(false);
    };
    var defaultMouseMove = this._on["mousemove.shape"];
    this._on["mousemove.shape"] = function (d, i) {
      defaultMouseMove(d, i);
      if (this$1._focus && this$1._focus === d.id) {
        this$1.hover(false);
        this$1._on.mouseenter.bind(this$1)(d, i);

        this$1._focus = undefined;
      }
      else {
        var id = this$1._nodeGroupBy && this$1._nodeGroupBy[this$1._drawDepth](d, i) ? this$1._nodeGroupBy[this$1._drawDepth](d, i) : this$1._id(d, i),
              links = this$1._linkLookup[id],
              node = this$1._nodeLookup[id];

        var filterIds = [node.id];
        var xDomain = [node.x - node.r, node.x + node.r],
              yDomain = [node.y - node.r, node.y + node.r];

        links.forEach(function (l) {
          filterIds.push(l.id);
          if (l.x - l.r < xDomain[0]) { xDomain[0] = l.x - l.r; }
          if (l.x + l.r > xDomain[1]) { xDomain[1] = l.x + l.r; }
          if (l.y - l.r < yDomain[0]) { yDomain[0] = l.y - l.r; }
          if (l.y + l.r > yDomain[1]) { yDomain[1] = l.y + l.r; }
        });

        this$1.hover(function (h, x) {
          if (h.source && h.target) { return h.source.id === node.id || h.target.id === node.id; }
          else { return filterIds.includes(this$1._ids(h, x)[this$1._drawDepth]); }
        });
      }
    };
    this._on["click.shape"] = function (d) {
      this$1._center = d.id;
      this$1._draw();
    };
    this._sizeMin = 5;
    this._sizeScale = "sqrt";
    this._shape = constant("Circle");
    this._shapeConfig = assign(this._shapeConfig, {
      ariaLabel: function (d, i) {
        var validSize = this$1._size ? (", " + (this$1._size(d, i))) : "";
        return ("" + (this$1._drawLabel(d, i)) + validSize + ".");
      },
      labelConfig: {
        duration: 0,
        fontMin: 1,
        fontResize: true,
        labelPadding: 0,
        textAnchor: "middle",
        verticalAlign: "middle"
      },
      Path: {
        fill: "none",
        label: false,
        stroke: "#eee",
        strokeWidth: 1
      }
    });

  }

  if ( Viz ) Rings.__proto__ = Viz;
  Rings.prototype = Object.create( Viz && Viz.prototype );
  Rings.prototype.constructor = Rings;

  /**
      Extends the draw behavior of the abstract Viz class.
      @private
  */
  Rings.prototype._draw = function _draw (callback) {
    var this$1 = this;


    Viz.prototype._draw.call(this, callback);

    var data = this._filteredData.reduce(function (obj, d, i) {
      obj[this$1._id(d, i)] = d;
      return obj;
    }, {});

    var nodes = this._nodes;

    if (!this._nodes.length && this._links.length) {
      var nodeIds = Array.from(new Set(this._links.reduce(function (ids, link) { return ids.concat([link.source, link.target]); }, [])));
      nodes = nodeIds.map(function (node) { return typeof node === "object" ? node : {id: node}; });
    }

    nodes = nodes.reduce(function (obj, d, i) {
      obj[this$1._nodeGroupBy ? this$1._nodeGroupBy[this$1._drawDepth](d, i) : this$1._id(d, i)] = d;
      return obj;
    }, {});

    nodes = Array.from(new Set(Object.keys(data).concat(Object.keys(nodes)))).map(function (id, i) {

      var d = data[id],
            n = nodes[id];

      if (n === undefined) { return false; }

      return {
        __d3plus__: true,
        data: d || n,
        i: i, id: id,
        node: n,
        shape: d !== undefined && this$1._shape(d) !== undefined ? this$1._shape(d) : this$1._shape(n)
      };

    }).filter(function (n) { return n; });

    var nodeLookup = this._nodeLookup = nodes.reduce(function (obj, d) {
      obj[d.id] = d;
      return obj;
    }, {});

    var links = this._links.map(function (link) {
      var check = ["source", "target"];
      return check.reduce(function (result, check) {
        result[check] = typeof link[check] === "number" ? nodes[link[check]] : nodeLookup[link[check].id || link[check]];
        return result;
      }, {});
    });

    var linkMap = links.reduce(function (map, link) {
      if (!map[link.source.id]) {
        map[link.source.id] = [];
      }
      map[link.source.id].push(link);
      if (!map[link.target.id]) {
        map[link.target.id] = [];
      }
      map[link.target.id].push(link);
      return map;
    }, {});

    var height = this._height - this._margin.top - this._margin.bottom,
          transform = "translate(" + (this._margin.left) + ", " + (this._margin.top) + ")",
          transition = this._transition,
          width = this._width - this._margin.left - this._margin.right;

    var edges = [],
          radius = min([height, width]) / 2,
          ringWidth = radius / 3;

    var primaryRing = ringWidth,
          secondaryRing = ringWidth * 2;

    var center = nodeLookup[this._center];

    center.x = width / 2;
    center.y = height / 2;
    center.r = this._sizeMin ? max([this._sizeMin, primaryRing * .65]) : this._sizeMax ? min([this._sizeMax, primaryRing * .65]) : primaryRing * .65;

    var claimed = [center],
          primaries = [];

    linkMap[this._center].forEach(function (edge) {
      var node = edge.source.id === this$1._center ? edge.target : edge.source;
      node.edges = linkMap[node.id].filter(function (link) { return link.source.id !== this$1._center || link.target.id !== this$1._center; });
      node.edge = edge;

      claimed.push(node);
      primaries.push(node);
    });

    primaries.sort(function (a, b) { return a.edges.length - b.edges.length; });

    var secondaries = [];
    var totalEndNodes = 0;

    primaries.forEach(function (p) {
      var primaryId = p.id;

      p.edges = p.edges.filter(function (edge) { return !claimed.includes(edge.source) && edge.target.id === primaryId ||
                                       !claimed.includes(edge.target) && edge.source.id === primaryId; });

      totalEndNodes += p.edges.length || 1;

      p.edges.forEach(function (edge) {
        var source = edge.source;
        var target = edge.target;
        var claim = target.id === primaryId ? source : target;
        claimed.push(claim);
      });
    });

    var tau = Math.PI * 2;
    var offset = 0;

    primaries.forEach(function (p, i) {
      var children = p.edges.length || 1;
      var space = tau / totalEndNodes * children;

      if (i === 0) {
        offset -= space / 2;
      }

      var angle = offset + space / 2 - tau / 4;

      p.radians = angle;
      p.x = width / 2 + primaryRing * Math.cos(angle);
      p.y = height / 2 + primaryRing * Math.sin(angle);

      offset += space;

      p.edges.forEach(function (edge, i) {
        var node = edge.source.id === p.id ? edge.target : edge.source;
        var s = tau / totalEndNodes;
        var a = angle - s * children / 2 + s / 2 + s * i;

        node.radians = a;
        node.x = width / 2 + secondaryRing * Math.cos(a);
        node.y = height / 2 + secondaryRing * Math.sin(a);

        secondaries.push(node);
      });
    });

    var primaryDistance = ringWidth / 2;
    var secondaryDistance = ringWidth / 4;

    var primaryMax = primaryDistance / 2 - 4;
    if (primaryDistance / 2 - 4 < 8) {
      primaryMax = min([primaryDistance / 2, 8]);
    }

    var secondaryMax = secondaryDistance / 2 - 4;
    if (secondaryDistance / 2 - 4 < 4) {
      secondaryMax = min([secondaryDistance / 2, 4]);
    }

    if (secondaryMax > ringWidth / 10) {
      secondaryMax = ringWidth / 10;
    }

    if (secondaryMax > primaryMax && secondaryMax > 10) {
      secondaryMax = primaryMax * .75;
    }
    if (primaryMax > secondaryMax * 1.5) {
      primaryMax = secondaryMax * 1.5;
    }

    primaryMax = Math.floor(primaryMax);
    secondaryMax = Math.floor(secondaryMax);

    var radiusFn;

    if (this._size) {
      var domain = extent(data, function (d) { return d.size; });

      if (domain[0] === domain[1]) {
        domain[0] = 0;
      }

      radiusFn = scales.scaleLinear()
        .domain(domain)
        .rangeRound([3, min([primaryMax, secondaryMax])]);

      var val = center.size;
      center.r = radiusFn(val);
    }
    else {
      radiusFn = scales.scaleLinear()
        .domain([1, 2])
        .rangeRound([primaryMax, secondaryMax]);
    }

    secondaries.forEach(function (s) {
      s.ring = 2;
      var val = this$1._size ? s.size : 2;
      s.r = this$1._sizeMin ? max([this$1._sizeMin, radiusFn(val)]) : this$1._sizeMax ? min([this$1._sizeMax, radiusFn(val)]) : radiusFn(val);
    });

    primaries.forEach(function (p) {
      p.ring = 1;
      var val = this$1._size ? p.size : 1;
      p.r = this$1._sizeMin ? max([this$1._sizeMin, radiusFn(val)]) : this$1._sizeMax ? min([this$1._sizeMax, radiusFn(val)]) : radiusFn(val);
    });

    nodes = [center].concat(primaries).concat(secondaries);

    primaries.forEach(function (p) {
      var check = ["source", "target"];
      var edge = p.edge;

      check.forEach(function (node) {
        edge[node] = nodes.find(function (n) { return n.id === edge[node].id; });
      });

      edges.push(edge);

      linkMap[p.id].forEach(function (edge) {
        var node = edge.source.id === p.id ? edge.target : edge.source;

        if (node.id !== center.id) {
          var target = secondaries.find(function (s) { return s.id === node.id; });

          if (!target) {
            target = primaries.find(function (s) { return s.id === node.id; });
          }

          if (target) {
            edge.spline = true;

            var centerX = width / 2;
            var centerY = height / 2;
            var middleRing = primaryRing + (secondaryRing - primaryRing) * 0.5;

            var check = ["source", "target"];

            check.forEach(function (node, i) {
              edge[(node + "X")] = edge[node].x + Math.cos(edge[node].ring === 2 ? edge[node].radians + Math.PI : edge[node].radians) * edge[node].r;
              edge[(node + "Y")] = edge[node].y + Math.sin(edge[node].ring === 2 ? edge[node].radians + Math.PI : edge[node].radians) * edge[node].r;
              edge[(node + "BisectX")] = centerX + middleRing * Math.cos(edge[node].radians);
              edge[(node + "BisectY")] = centerY + middleRing * Math.sin(edge[node].radians);

              edge[node] = nodes.find(function (n) { return n.id === edge[node].id; });

              if (edge[node].edges === undefined) { edge[node].edges = {}; }

              var oppId = i === 0 ? edge.target.id : edge.source.id;

              if (edge[node].id === p.id) {
                edge[node].edges[oppId] = {
                  angle: p.radians + Math.PI,
                  radius: ringWidth / 2
                };
              }
              else {
                edge[node].edges[oppId] = {
                  angle: target.radians,
                  radius: ringWidth / 2
                };
              }
            });

            edges.push(edge);
          }
        }
      });
    });

    nodes.forEach(function (node) {

      if (node.id !== this$1._center) {
        var fontSize = this$1._shapeConfig.labelConfig.fontSize && this$1._shapeConfig.labelConfig.fontSize(node) || 11;
        var lineHeight = fontSize * 1.4;
        var height = lineHeight * 2;
        var padding = 5;
        var width = ringWidth - node.r;

        var angle = node.radians * (180 / Math.PI);
        var x = node.r + padding;
        var textAnchor = "start";

        if (angle < -90 || angle > 90) {
          x = -node.r - width - padding;
          textAnchor = "end";
          angle += 180;
        }

        node.labelBounds = {
          x: x,
          y: -lineHeight / 2,
          width: width,
          height: height
        };

        node.rotate = angle;
        node.textAnchor = textAnchor;
      }
      else {
        node.labelBounds = {
          x: -primaryRing / 2,
          y: -primaryRing / 2,
          width: primaryRing,
          height: primaryRing
        };
      }
    });

    this._linkLookup = links.reduce(function (obj, d) {
      if (!obj[d.source.id]) { obj[d.source.id] = []; }
      obj[d.source.id].push(d.target);
      if (!obj[d.target.id]) { obj[d.target.id] = []; }
      obj[d.target.id].push(d.source);
      return obj;
    }, {});

    this._shapes.push(new shapes.Path()
      .config(configPrep.bind(this)(this._shapeConfig, "edge", "Path"))
      .id(function (d) { return ((d.source.id) + "_" + (d.target.id)); })
      .d(function (d) { return d.spline ? ("M" + (d.sourceX) + "," + (d.sourceY) + "C" + (d.sourceBisectX) + "," + (d.sourceBisectY) + " " + (d.targetBisectX) + "," + (d.targetBisectY) + " " + (d.targetX) + "," + (d.targetY)) : ("M" + (d.source.x) + "," + (d.source.y) + " " + (d.target.x) + "," + (d.target.y)); })
      .data(edges)
      .select(elem("g.d3plus-rings-links", {parent: this._select, transition: transition, enter: {transform: transform}, update: {transform: transform}}).node())
      .render());

    var that = this;

    var shapeConfig = {
      label: function (d) { return nodes.length <= this$1._labelCutoff || (this$1._hover && this$1._hover(d) || this$1._active && this$1._active(d)) ? this$1._drawLabel(d.data || d.node, d.i) : false; },
      labelBounds: function (d) { return d.labelBounds; },
      labelConfig: {
        fontColor: function (d) { return d.data.data.id === this$1._center ? configPrep.bind(that)(that._shapeConfig, "shape", d.key).labelConfig.fontColor(d) : colorLegible(configPrep.bind(that)(that._shapeConfig, "shape", d.key).fill(d)); },
        fontResize: function (d) { return d.data.data.id === this$1._center; },
        padding: 0,
        textAnchor: function (d) { return nodeLookup[d.data.data.id].textAnchor || configPrep.bind(that)(that._shapeConfig, "shape", d.key).labelConfig.textAnchor; },
        verticalAlign: function (d) { return d.data.data.id === this$1._center ? "middle" : "top"; }
      },
      rotate: function (d) { return nodeLookup[d.id].rotate || 0; },
      select: elem("g.d3plus-rings-nodes", {parent: this._select, transition: transition, enter: {transform: transform}, update: {transform: transform}}).node()
    };

    nest().key(function (d) { return d.shape; }).entries(nodes).forEach(function (d) {
      this$1._shapes.push(new shapes[d.key]()
        .config(configPrep.bind(this$1)(this$1._shapeConfig, "shape", d.key))
        .config(shapeConfig)
        .data(d.values)
        .render());
    });

    return this;

  };

  /**
   @memberof Rings
   @desc Sets the center node to be the node with the given id.
   @param {String}
   @chainable
   */
  Rings.prototype.center = function center (_) {
    return arguments.length ? (this._center = _, this) : this._center;
  };

  /**
      @memberof Rings
      @desc If *value* is specified, sets the hover method to the specified function and returns the current class instance.
      @param {Function} [*value*]
      @chainable
   */
  Rings.prototype.hover = function hover (_) {
    this._hover = _;

    this._shapes.forEach(function (s) { return s.hover(_); });
    if (this._legend) { this._legendClass.hover(_); }

    return this;
  };

  /**
      @memberof Rings
      @desc A predefined *Array* of edges that connect each object passed to the [node](#Rings.node) method. The `source` and `target` keys in each link need to map to the nodes in one of three ways:
1. The index of the node in the nodes array (as in [this](http://d3plus.org/examples/d3plus-network/getting-started/) example).
2. The actual node *Object* itself.
3. A *String* value matching the `id` of the node.

The value passed should either be an *Array* of data or a *String* representing a filepath or URL to be loaded. An optional formatting function can be passed as a second argument to this method. This custom function will be passed the data that has been loaded, as long as there are no errors. This function should return the final links *Array*.
      @param {Array|String} *links* = []
      @param {Function} [*formatter*]
      @chainable
  */
  Rings.prototype.links = function links (_, f) {
    if (arguments.length) {
      var prev = this._queue.find(function (q) { return q[3] === "links"; });
      var d = [load.bind(this), _, f, "links"];
      if (prev) { this._queue[this._queue.indexOf(prev)] = d; }
      else { this._queue.push(d); }
      return this;
    }
    return this._links;
  };

  /**
      @memberof Rings
      @desc If *value* is specified, sets the node group accessor(s) to the specified string, function, or array of values and returns the current class instance. This method overrides the default .groupBy() function from being used with the data passed to .nodes(). If *value* is not specified, returns the current node group accessor.
      @param {String|Function|Array} [*value* = undefined]
      @chainable
  */
  Rings.prototype.nodeGroupBy = function nodeGroupBy (_) {
    var this$1 = this;

    if (!arguments.length) { return this._nodeGroupBy; }
    if (!(_ instanceof Array)) { _ = [_]; }
    return this._nodeGroupBy = _.map(function (k) {
      if (typeof k === "function") { return k; }
      else {
        if (!this$1._aggs[k]) {
          this$1._aggs[k] = function (a) {
            var v = Array.from(new Set(a));
            return v.length === 1 ? v[0] : v;
          };
        }
        return accessor(k);
      }
    }), this;
  };

  /**
      @memberof Rings
      @desc The list of nodes to be used for drawing the rings network. The value passed should either be an *Array* of data or a *String* representing a filepath or URL to be loaded.

Additionally, a custom formatting function can be passed as a second argument to this method. This custom function will be passed the data that has been loaded, as long as there are no errors. This function should return the final node *Array*.
      @param {Array|String} *nodes* = []
      @param {Function} [*formatter*]
      @chainable
  */
  Rings.prototype.nodes = function nodes (_, f) {
    if (arguments.length) {
      var prev = this._queue.find(function (q) { return q[3] === "nodes"; });
      var d = [load.bind(this), _, f, "nodes"];
      if (prev) { this._queue[this._queue.indexOf(prev)] = d; }
      else { this._queue.push(d); }
      return this;
    }
    return this._nodes;
  };

  /**
      @memberof Rings
      @desc If *value* is specified, sets the size accessor to the specified function or data key and returns the current class instance. If *value* is not specified, returns the current size accessor.
      @param {Function|String} [*value*]
      @chainable
  */
  Rings.prototype.size = function size (_) {
    return arguments.length ? (this._size = typeof _ === "function" || !_ ? _ : accessor(_), this) : this._size;
  };

  /**
      @memberof Rings
      @desc If *value* is specified, sets the size scale maximum to the specified number and returns the current class instance. If *value* is not specified, returns the current size scale maximum. By default, the maximum size is determined by half the distance of the two closest nodes.
      @param {Number} [*value*]
      @chainable
  */
  Rings.prototype.sizeMax = function sizeMax (_) {
    return arguments.length ? (this._sizeMax = _, this) : this._sizeMax;
  };

  /**
      @memberof Rings
      @desc If *value* is specified, sets the size scale minimum to the specified number and returns the current class instance. If *value* is not specified, returns the current size scale minimum.
      @param {Number} [*value* = 5]
      @chainable
  */
  Rings.prototype.sizeMin = function sizeMin (_) {
    return arguments.length ? (this._sizeMin = _, this) : this._sizeMin;
  };

  /**
      @memberof Rings
      @desc If *value* is specified, sets the size scale to the specified string and returns the current class instance. If *value* is not specified, returns the current size scale.
      @param {String} [*value* = "sqrt"]
      @chainable
  */
  Rings.prototype.sizeScale = function sizeScale (_) {
    return arguments.length ? (this._sizeScale = _, this) : this._sizeScale;
  };

  return Rings;
}(Viz));

export default Rings;

//# sourceMappingURL=Rings.js.map