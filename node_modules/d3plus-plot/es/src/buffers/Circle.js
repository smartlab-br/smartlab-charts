import {default as ordinalBuffer} from "./ordinalBuffer";

/**
    Adds a buffer to either side of the non-discrete axis.
    @param {Array} data
    @param {D3Scale} x
    @param {D3Scale} y
    @param {Object} [config]
    @param {Number} [buffer] Defaults to the radius of the largest Circle.
    @private
*/
export default function(ref) {
  var data = ref.data;
  var x = ref.x;
  var y = ref.y;
  var x2 = ref.x2;
  var y2 = ref.y2;
  var config = ref.config;
  var buffer = ref.buffer;

  var xKey = x2 ? "x2" : "x";
  var yKey = y2 ? "y2" : "y";

  var xD = x.domain().slice(),
      yD = y.domain().slice();

  var xR = x.range(),
        yR = y.range();

  if (!x.invert) { xD = ordinalBuffer(xD); }
  if (!y.invert) { yD = ordinalBuffer(yD); }

  data.forEach(function (d) {

    var s = buffer ? buffer : config.r(d.data, d.i) * 2;

    if (x.invert && x(d[xKey]) - xR[0] < s) {
      var v = x.invert(x(d[xKey]) - s);
      if (v < xD[0]) { xD[0] = v; }
    }
    if (x.invert && xR[1] - x(d[xKey]) < s) {
      var v$1 = x.invert(x(d[xKey]) + s);
      if (v$1 > xD[1]) { xD[1] = v$1; }
    }

    if (y.invert && y(d[yKey]) - yR[0] < s) {
      var v$2 = y.invert(y(d[yKey]) - s);
      if (v$2 > yD[0]) { yD[0] = v$2; }
    }
    if (y.invert && yR[1] - y(d[yKey]) < s) {
      var v$3 = y.invert(y(d[yKey]) + s);
      if (v$3 < yD[1]) { yD[1] = v$3; }
    }

  });

  x.domain(xD).range(xR);
  y.domain(yD).range(yR);

  return [x, y];

}

//# sourceMappingURL=Circle.js.map