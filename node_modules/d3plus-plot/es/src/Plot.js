import {extent, max, merge, min, range, sum} from "d3-array";
import {nest} from "d3-collection";
import * as scales from "d3-scale";
import * as d3Shape from "d3-shape";

import {AxisBottom, AxisLeft, AxisRight, AxisTop, date} from "d3plus-axis";
import {colorAssign} from "d3plus-color";
import {accessor, assign, configPrep, constant, elem} from "d3plus-common";
import * as shapes from "d3plus-shape";
import {Viz} from "d3plus-viz";

import {default as BarBuffer} from "./buffers/Bar.js";
import {default as BoxBuffer} from "./buffers/Box.js";
import {default as CircleBuffer} from "./buffers/Circle.js";
import {default as LineBuffer} from "./buffers/Line.js";
import {default as RectBuffer} from "./buffers/Rect.js";

function defaultSize(d) {
  return this._sizeScaleD3(this._size ? this._size(d) : null);
}

/**
    @class Plot
    @extends Viz
    @desc Creates an x/y plot based on an array of data.
*/
var Plot = (function (Viz) {
  function Plot() {
    var this$1 = this;


    Viz.call(this);
    this._annotations = [];
    this._barPadding = 0;
    this._buffer = {
      Bar: BarBuffer,
      Box: BoxBuffer,
      Circle: CircleBuffer,
      Line: LineBuffer,
      Rect: RectBuffer
    };
    this._confidenceConfig = {
      fillOpacity: constant(0.5)
    };
    this._groupPadding = 5;
    this._shape = constant("Circle");
    this._shapeConfig = assign(this._shapeConfig, {
      Area: {
        label: function (d, i) { return this$1._stacked ? this$1._drawLabel(d, i) : false; },
        labelConfig: {
          fontResize: true
        }
      },
      ariaLabel: function (d, i) {
        var ariaLabelStr = "";
        if (d.nested) { ariaLabelStr = "" + (this$1._drawLabel(d.data, d.i)); }
        else {
          ariaLabelStr = "" + (this$1._drawLabel(d, i));
          if (this$1._x(d, i) !== undefined) { ariaLabelStr += ", x: " + (this$1._x(d, i)); }
          if (this$1._y(d, i) !== undefined) { ariaLabelStr += ", y: " + (this$1._y(d, i)); }
          if (this$1._x2(d, i) !== undefined) { ariaLabelStr += ", x2: " + (this$1._x2(d, i)); }
          if (this$1._y2(d, i) !== undefined) { ariaLabelStr += ", y2: " + (this$1._y2(d, i)); }
        }
        return (ariaLabelStr + ".");
      },
      Bar: {
        labelConfig: {
          textAnchor: function () { return this$1._discrete === "x" ? "middle" : "end"; },
          verticalAlign: function () { return this$1._discrete === "x" ? "top" : "middle"; }
        }
      },
      Circle: {
        r: defaultSize.bind(this)
      },
      Line: {
        fill: constant("none"),
        label: false,
        stroke: function (d, i) { return colorAssign(this$1._id(d, i)); },
        strokeWidth: constant(1)
      },
      Rect: {
        height: function (d) { return defaultSize.bind(this$1)(d) * 2; },
        width: function (d) { return defaultSize.bind(this$1)(d) * 2; }
      }
    });
    this._shapeOrder = ["Area", "Path", "Bar", "Box", "Line", "Rect", "Circle"];
    this._shapeSort = function (a, b) { return this$1._shapeOrder.indexOf(a) - this$1._shapeOrder.indexOf(b); };
    this._sizeMax = 20;
    this._sizeMin = 5;
    this._sizeScale = "sqrt";
    this._stackOffset = d3Shape.stackOffsetDiverging;
    this._stackOrder = d3Shape.stackOrderNone;
    this._x = accessor("x");
    this._x2 = accessor("x2");
    this._xAxis = new AxisBottom().align("end");
    this._x2Axis = new AxisTop().align("start");
    this._xTest = new AxisBottom().align("end").gridSize(0);
    this._x2Test = new AxisTop().align("start").gridSize(0);
    this._xConfig = {};
    this._x2Config = {
      padding: 0
    };
    this._y = accessor("y");
    this._y2 = accessor("y2");
    this._yAxis = new AxisLeft().align("start");
    this._yTest = new AxisLeft().align("start").gridSize(0);
    this._y2Axis = new AxisRight().align("end");
    this._y2Test = new AxisLeft().align("end").gridSize(0);
    this._yConfig = {
      gridConfig: {
        stroke: function (d) {
          var domain = this$1._yAxis.domain();
          return domain[domain.length - 1] === d.id ? "transparent" : "#ccc";
        }
      }
    };
    this._y2Config = {};

  }

  if ( Viz ) Plot.__proto__ = Viz;
  Plot.prototype = Object.create( Viz && Viz.prototype );
  Plot.prototype.constructor = Plot;

  /**
      Extends the draw behavior of the abstract Viz class.
      @private
  */
  Plot.prototype._draw = function _draw (callback) {
    var this$1 = this;


    if (!this._filteredData.length) { return this; }

    var stackGroup = function (d, i) { return this$1._stacked
      ? ("" + (this$1._groupBy.length > 1 ? this$1._ids(d, i).slice(0, -1).join("_") : "group"))
      : ("" + (this$1._ids(d, i).join("_"))); };

    var data = this._filteredData.map(function (d, i) { return ({
      __d3plus__: true,
      data: d,
      group: stackGroup(d, i),
      i: i,
      hci: this$1._confidence && this$1._confidence[1] && this$1._confidence[1](d, i),
      id: this$1._ids(d, i).slice(0, this$1._drawDepth + 1).join("_"),
      lci: this$1._confidence && this$1._confidence[0] && this$1._confidence[0](d, i),
      shape: this$1._shape(d, i),
      x: this$1._x(d, i),
      x2: this$1._x2(d, i),
      y: this$1._y(d, i),
      y2: this$1._y2(d, i)
    }); });

    this._formattedData = data;

    if (this._size) {
      var rExtent = extent(data, function (d) { return this$1._size(d.data); });
      this._sizeScaleD3 = function () { return this$1._sizeMin; };
      this._sizeScaleD3 = scales[("scale" + (this._sizeScale.charAt(0).toUpperCase()) + (this._sizeScale.slice(1)))]()
        .domain(rExtent)
        .range([rExtent[0] === rExtent[1] ? this._sizeMax : min([this._sizeMax / 2, this._sizeMin]), this._sizeMax]);
    }
    else {
      this._sizeScaleD3 = function () { return this$1._sizeMin; };
    }

    var x2Exists = data.some(function (d) { return d.x2 !== undefined; }),
          y2Exists = data.some(function (d) { return d.y2 !== undefined; });

    var height = this._height - this._margin.top - this._margin.bottom,
          opp = this._discrete ? this._discrete === "x" ? "y" : "x" : undefined,
          opp2 = this._discrete ? this._discrete === "x" ? "y2" : "x2" : undefined,
          opps = [opp, opp2],
          parent = this._select,
          transition = this._transition,
          width = this._width - this._margin.left - this._margin.right;

    var x2Time = this._time && data[0].x2 === this._time(data[0].data, data[0].i),
          xTime = this._time && data[0].x === this._time(data[0].data, data[0].i),
          y2Time = this._time && data[0].y2 === this._time(data[0].data, data[0].i),
          yTime = this._time && data[0].y === this._time(data[0].data, data[0].i);

    for (var i = 0; i < data.length; i++) {
      var d = data[i];
      if (xTime) { d.x = date(d.x); }
      if (x2Time) { d.x2 = date(d.x2); }
      if (yTime) { d.y = date(d.y); }
      if (y2Time) { d.y2 = date(d.y2); }
      d.discrete = d.shape === "Bar" ? ((d[this$1._discrete]) + "_" + (d.group)) : ("" + (d[this$1._discrete]));
    }

    var discreteKeys, domains, stackData, stackKeys;
    if (this._stacked) {

      var groupValues = nest()
        .key(function (d) { return d.group; })
        .entries(data)
        .reduce(function (obj, d) {
          if (!obj[d.key]) { obj[d.key] = 0; }
          obj[d.key] += sum(d.values, function (dd) { return dd[opp]; });
          return obj;
        }, {});

      data = data.sort(function (a, b) {
        if (this$1[("_" + (this$1._discrete) + "Sort")]) { return this$1[("_" + (this$1._discrete) + "Sort")](a.data, b.data); }
        var a1 = a[this$1._discrete], b1 = b[this$1._discrete];
        if (a1 - b1 !== 0) { return a1 - b1; }
        if (a.group !== b.group) { return groupValues[b.group] - groupValues[a.group]; }
        return b[opp] - a[opp];
      });

      discreteKeys = Array.from(new Set(data.map(function (d) { return d.discrete; })));
      stackKeys = Array.from(new Set(data.map(function (d) { return d.id; })));

      stackData = nest()
        .key(function (d) { return d.discrete; })
        .entries(data)
        .map(function (d) { return d.values; });

      stackData.forEach(function (g) {
        var ids = Array.from(new Set(g.map(function (d) { return d.id; })));
        if (ids.length < stackKeys.length) {
          stackKeys.forEach(function (k) {
            if (!ids.includes(k)) {
              var d = data.filter(function (d) { return d.id === k; })[0];
              if (d.shape === "Area") {
                var group = stackGroup(d.data, d.i);
                var fillerPoint = {
                  __d3plus__: true,
                  data: d.data,
                  discrete: d.shape === "Bar" ? ((g[0][this$1._discrete]) + "_" + group) : ("" + (g[0][this$1._discrete])),
                  group: group,
                  id: k,
                  shape: d.shape
                };
                fillerPoint[this$1._discrete] = g[0][this$1._discrete];
                fillerPoint[opp] = 0;
                data.push(fillerPoint);
              }
            }
          });
        }
      });

      if (this[("_" + (this._discrete) + "Sort")]) {
        data.sort(function (a, b) { return this$1[("_" + (this$1._discrete) + "Sort")](a.data, b.data); });
      }
      else {
        data.sort(function (a, b) { return a[this$1._discrete] - b[this$1._discrete]; });
      }
      var order = this._stackOrder;

      if (order instanceof Array) { stackKeys.sort(function (a, b) { return order.indexOf(a) - order.indexOf(b); }); }
      else if (order === d3Shape.stackOrderNone) { stackKeys.sort(function (a, b) { return a.localeCompare(b); }); }

      stackData = d3Shape.stack()
        .keys(stackKeys)
        .offset(this._stackOffset)
        .order(order instanceof Array ? d3Shape.stackOrderNone : order)
        .value(function (group, key) {
          var d = group.filter(function (g) { return g.id === key; });
          return d.length ? d[0][opp] : 0;
        })(stackData);

      domains = {};
      domains[this._discrete] = extent(data, function (d) { return d[this$1._discrete]; });
      domains[opp] = [min(stackData.map(function (g) { return min(g.map(function (p) { return p[0]; })); })), max(stackData.map(function (g) { return max(g.map(function (p) { return p[1]; })); }))];

    }
    else {
      var xData = this._discrete === "x" ? data.map(function (d) { return d.x; }) : data.map(function (d) { return d.x; })
        .concat(this._confidence && this._confidence[0] ? data.map(function (d) { return d.lci; }) : [])
        .concat(this._confidence && this._confidence[1] ? data.map(function (d) { return d.hci; }) : []);

      var x2Data = this._discrete === "x" ? data.map(function (d) { return d.x2; }) : data.map(function (d) { return d.x2; })
        .concat(this._confidence && this._confidence[0] ? data.map(function (d) { return d.lci; }) : [])
        .concat(this._confidence && this._confidence[1] ? data.map(function (d) { return d.hci; }) : []);

      var yData = this._discrete === "y" ? data.map(function (d) { return d.y; }) : data.map(function (d) { return d.y; })
        .concat(this._confidence && this._confidence[0] ? data.map(function (d) { return d.lci; }) : [])
        .concat(this._confidence && this._confidence[1] ? data.map(function (d) { return d.hci; }) : []);

      var y2Data = this._discrete === "y" ? data.map(function (d) { return d.y2; }) : data.map(function (d) { return d.y2; })
        .concat(this._confidence && this._confidence[0] ? data.map(function (d) { return d.lci; }) : [])
        .concat(this._confidence && this._confidence[1] ? data.map(function (d) { return d.hci; }) : []);

      if (this[("_" + (this._discrete) + "Sort")]) {
        data.sort(function (a, b) { return this$1[("_" + (this$1._discrete) + "Sort")](a.data, b.data); });
      }
      else {
        data.sort(function (a, b) { return a[this$1._discrete] - b[this$1._discrete]; });
      }

      domains = {
        x: this._xSort ? Array.from(new Set(data.filter(function (d) { return d.x; }).sort(function (a, b) { return this$1._xSort(a.data, b.data); }).map(function (d) { return d.x; }))) : extent(xData, function (d) { return d; }),
        x2: this._x2Sort ? Array.from(new Set(data.filter(function (d) { return d.x2; }).sort(function (a, b) { return this$1._x2Sort(a.data, b.data); }).map(function (d) { return d.x2; }))) : extent(x2Data, function (d) { return d; }),
        y: this._ySort ? Array.from(new Set(data.filter(function (d) { return d.y; }).sort(function (a, b) { return this$1._ySort(a.data, b.data); }).map(function (d) { return d.y; }))) : extent(yData, function (d) { return d; }),
        y2: this._y2Sort ? Array.from(new Set(data.filter(function (d) { return d.y2; }).sort(function (a, b) { return this$1._y2Sort(a.data, b.data); }).map(function (d) { return d.y2; }))) : extent(y2Data, function (d) { return d; })
      };
    }

    var xDomain = this._xDomain ? this._xDomain.slice() : domains.x,
        xScale = this._xSort ? "Ordinal" : "Linear";

    if (xDomain[0] === void 0) { xDomain[0] = domains.x[0]; }
    if (xDomain[1] === void 0) { xDomain[1] = domains.x[1]; }

    if (xTime) {
      xDomain = xDomain.map(date);
      xScale = "Time";
    }
    else if (this._discrete === "x") {
      xDomain = Array.from(new Set(data.filter(function (d) { return d.x; }).sort(function (a, b) { return this$1._xSort ? this$1._xSort(a.data, b.data) : a.x - b.x; }).map(function (d) { return d.x; })));
      xScale = "Ordinal";
    }

    var x2Domain = this._x2Domain ? this._x2Domain.slice() : domains.x2,
        x2Scale = this._x2Sort ? "Ordinal" : "Linear";

    if (x2Domain && x2Domain[0] === void 0) { x2Domain[0] = domains.x2[0]; }
    if (x2Domain && x2Domain[1] === void 0) { x2Domain[1] = domains.x2[1]; }

    if (x2Time) {
      x2Domain = x2Domain.map(date);
      x2Scale = "Time";
    }
    else if (this._discrete === "x") {
      x2Domain = Array.from(new Set(data.filter(function (d) { return d.x2; }).sort(function (a, b) { return this$1._x2Sort ? this$1._x2Sort(a.data, b.data) : a.x2 - b.x2; }).map(function (d) { return d.x2; })));
      x2Scale = "Ordinal";
    }

    var yDomain = this._yDomain ? this._yDomain.slice() : domains.y,
        yScale = this._ySort ? "Ordinal" : "Linear";

    if (yDomain[0] === void 0) { yDomain[0] = domains.y[0]; }
    if (yDomain[1] === void 0) { yDomain[1] = domains.y[1]; }

    var y2Domain = this._y2Domain ? this._y2Domain.slice() : domains.y2,
        y2Scale = this._y2Sort ? "Ordinal" : "Linear";

    if (y2Domain && y2Domain[0] === void 0) { y2Domain[0] = domains.y2[0]; }
    if (y2Domain && y2Domain[1] === void 0) { y2Domain[1] = domains.y2[1]; }

    if (yTime) {
      yDomain = yDomain.map(date);
      yScale = "Time";
    }
    else if (this._discrete === "y") {
      yDomain = Array.from(new Set(data.sort(function (a, b) { return this$1._ySort ? this$1._ySort(a.data, b.data) : a.y - b.y; }).map(function (d) { return d.y; })));
      yScale = "Ordinal";

      y2Domain = Array.from(new Set(data.sort(function (a, b) { return this$1._y2Sort ? this$1._y2Sort(a.data, b.data) : a.y2 - b.y2; }).map(function (d) { return d.y2; })));
      y2Scale = "Ordinal";
    }

    if (y2Time) {
      y2Domain = y2Domain.map(date);
      y2Scale = "Time";
    }

    domains = {x: xDomain, x2: x2Domain || xDomain, y: yDomain, y2: y2Domain || yDomain};

    opps.forEach(function (opp) {
      if (opp && this$1._baseline !== void 0) {
        var b = this$1._baseline;
        if (domains[opp] && domains[opp][0] > b) { domains[opp][0] = b; }
        else if (domains[opp] && domains[opp][1] < b) { domains[opp][1] = b; }
      }
    });

    var x = scales[("scale" + xScale)]().domain(domains.x).range(range(0, width + 1, width / (domains.x.length - 1))),
        x2 = scales[("scale" + x2Scale)]().domain(domains.x2).range(range(0, width + 1, width / (domains.x2.length - 1))),
        y = scales[("scale" + yScale)]().domain(domains.y.reverse()).range(range(0, height + 1, height / (domains.y.length - 1))),
        y2 = scales[("scale" + y2Scale)]().domain(domains.y2.reverse()).range(range(0, height + 1, height / (domains.y2.length - 1)));

    var shapeData = nest()
      .key(function (d) { return d.shape; })
      .entries(data)
      .sort(function (a, b) { return this$1._shapeSort(a.key, b.key); });

    var oppScale = this._discrete === "x" ? yScale : xScale;
    if (this._xConfig.scale !== "log" && this._yConfig.scale !== "log" && oppScale !== "Ordinal") {
      shapeData.forEach(function (d) {
        if (this$1._buffer[d.key]) {
          var res = this$1._buffer[d.key].bind(this$1)({data: d.values, x: x, y: y, config: this$1._shapeConfig[d.key]});
          if (this$1._xConfig.scale !== "log") { x = res[0]; }
          if (this$1._yConfig.scale !== "log") { y = res[1]; }
          var res2 = this$1._buffer[d.key].bind(this$1)({data: d.values, x: x2, y: y2, x2: true, y2: true, config: this$1._shapeConfig[d.key]});
          if (this$1._x2Config.scale !== "log") { x2 = res2[0]; }
          if (this$1._y2Config.scale !== "log") { y2 = res2[1]; }
        }
      });
    }
    xDomain = x.domain();
    x2Domain = x2.domain();
    yDomain = y.domain();
    y2Domain = y2.domain();

    var testGroup = elem("g.d3plus-plot-test", {enter: {opacity: 0}, parent: this._select}),
          x2Ticks = this._discrete === "x" && !x2Time ? domains.x2 : undefined,
          xTicks = this._discrete === "x" && !xTime ? domains.x : undefined,
          y2Ticks = this._discrete === "y" && !y2Time ? domains.y2 : undefined,
          yTicks = this._discrete === "y" && !yTime ? domains.y : undefined;

    var yC = {
      gridConfig: {stroke: !this._discrete || this._discrete === "x" ? this._yTest.gridConfig().stroke : "transparent"}
    };

    var defaultConfig = {
      barConfig: {"stroke-width": 0},
      gridSize: 0,
      labels: [],
      title: false,
      tickSize: 0
    };

    var defaultX2Config = x2Exists ? {} : defaultConfig;
    var defaultY2Config = y2Exists ? {} : defaultConfig;

    this._yTest
      .domain(yDomain)
      .height(height)
      .maxSize(width / 2)
      .range([undefined, undefined])
      .scale(yScale.toLowerCase())
      .select(testGroup.node())
      .ticks(yTicks)
      .width(width)
      .config(yC)
      .config(this._yConfig)
      .render();

    var yBounds = this._yTest.outerBounds();
    var yWidth = yBounds.width ? yBounds.width + this._yTest.padding() : undefined;

    if (y2Exists) {
      this._y2Test
        .domain(y2Domain)
        .height(height)
        .range([undefined, undefined])
        .scale(y2Scale.toLowerCase())
        .select(testGroup.node())
        .ticks(y2Ticks)
        .width(width)
        .config(yC)
        .config(defaultY2Config)
        .config(this._y2Config)
        .render();
    }

    var y2Bounds = this._y2Test.outerBounds();
    var y2Width = y2Bounds.width ? y2Bounds.width + this._y2Test.padding() : undefined;

    var xC = {
      gridConfig: {stroke: !this._discrete || this._discrete === "y" ? this._xTest.gridConfig().stroke : "transparent"}
    };

    this._xTest
      .domain(xDomain)
      .height(height)
      .maxSize(height / 2)
      .range([undefined, undefined])
      .scale(xScale.toLowerCase())
      .select(testGroup.node())
      .ticks(xTicks)
      .width(width)
      .config(xC)
      .config(this._xConfig)
      .render();

    if (x2Exists) {
      this._x2Test
        .domain(x2Domain)
        .height(height)
        .range([undefined, undefined])
        .scale(x2Scale.toLowerCase())
        .select(testGroup.node())
        .ticks(x2Ticks)
        .width(width)
        .config(xC)
        .tickSize(0)
        .config(defaultX2Config)
        .config(this._x2Config)
        .render();
    }

    var xTestRange = this._xTest._getRange();
    var x2TestRange = this._x2Test._getRange();

    var x2Bounds = this._x2Test.outerBounds();
    var x2Height = x2Bounds.height + this._x2Test.padding();

    var xOffsetLeft = max([yWidth, xTestRange[0], x2TestRange[0]]);

    this._xTest
      .range([xOffsetLeft, undefined])
      .render();

    var topOffset = this._yTest.shapeConfig().labelConfig.fontSize() / 2;

    var xOffsetRight = max([y2Width, width - xTestRange[1], width - x2TestRange[1]]);
    var xBounds = this._xTest.outerBounds();
    var xHeight = xBounds.height + this._xTest.padding();

    this._padding.left += xOffsetLeft;
    this._padding.right += xOffsetRight;
    this._padding.bottom += xHeight;
    this._padding.top += x2Height + topOffset;

    Viz.prototype._draw.call(this, callback);

    var horizontalMargin = this._margin.left + this._margin.right;
    var verticalMargin = this._margin.top + this._margin.bottom;
    this._yTest
      .domain(yDomain)
      .height(height)
      .maxSize(width / 2)
      .range([x2Height, height - (xHeight + topOffset + verticalMargin)])
      .scale(yScale.toLowerCase())
      .select(testGroup.node())
      .ticks(yTicks)
      .width(width)
      .config(yC)
      .config(this._yConfig)
      .render();

    yBounds = this._yTest.outerBounds();
    yWidth = yBounds.width ? yBounds.width + this._yTest.padding() : undefined;
    xOffsetLeft = max([yWidth, xTestRange[0], x2TestRange[0]]);

    if (y2Exists) {
      this._y2Test
        .config(yC)
        .domain(y2Domain)
        .gridSize(0)
        .height(height)
        .range([x2Height, height - (xHeight + topOffset + verticalMargin)])
        .scale(y2Scale.toLowerCase())
        .select(testGroup.node())
        .width(width - max([0, xOffsetRight - y2Width]))
        .title(false)
        .config(this._y2Config)
        .config(defaultY2Config)
        .render();
    }

    y2Bounds = this._y2Test.outerBounds();
    y2Width = y2Bounds.width ? y2Bounds.width + this._y2Test.padding() : undefined;
    xOffsetRight = max([y2Width, width - xTestRange[1], width - x2TestRange[1]]);

    var transform = "translate(" + (this._margin.left) + ", " + (this._margin.top + x2Height + topOffset) + ")";
    var x2Transform = "translate(" + (this._margin.left) + ", " + (this._margin.top + topOffset) + ")";

    var xGroup = elem("g.d3plus-plot-x-axis", {parent: parent, transition: transition, enter: {transform: transform}, update: {transform: transform}});
    var x2Group = elem("g.d3plus-plot-x2-axis", {parent: parent, transition: transition, enter: {transform: x2Transform}, update: {transform: x2Transform}});

    var xTrans = xOffsetLeft > yWidth ? xOffsetLeft - yWidth : 0;
    var yTransform = "translate(" + (this._margin.left + xTrans) + ", " + (this._margin.top + topOffset) + ")";
    var yGroup = elem("g.d3plus-plot-y-axis", {parent: parent, transition: transition, enter: {transform: yTransform}, update: {transform: yTransform}});

    var y2Transform = "translate(-" + (this._margin.right) + ", " + (this._margin.top + topOffset) + ")";
    var y2Group = elem("g.d3plus-plot-y2-axis", {parent: parent, transition: transition, enter: {transform: y2Transform}, update: {transform: y2Transform}});

    this._xAxis
      .domain(xDomain)
      .height(height - (x2Height + topOffset + verticalMargin))
      .maxSize(height / 2)
      .range([xOffsetLeft, width - (xOffsetRight + horizontalMargin)])
      .scale(xScale.toLowerCase())
      .select(xGroup.node())
      .ticks(xTicks)
      .width(width)
      .config(xC)
      .config(this._xConfig)
      .render();

    if (x2Exists) {
      this._x2Axis
        .domain(x2Domain)
        .height(height - (xHeight + topOffset + verticalMargin))
        .range([xOffsetLeft, width - (xOffsetRight + horizontalMargin)])
        .scale(x2Scale.toLowerCase())
        .select(x2Group.node())
        .ticks(x2Ticks)
        .width(width)
        .config(xC)
        .config(defaultX2Config)
        .config(this._x2Config)
        .render();
    }

    x = function (d, x) {
      if (x === "x2") {
        if (this$1._x2Config.scale === "log" && d === 0) { d = x2Domain[0] < 0 ? -1 : 1; }
        return this$1._x2Axis._getPosition.bind(this$1._x2Axis)(d);
      }
      else {
        if (this$1._xConfig.scale === "log" && d === 0) { d = xDomain[0] < 0 ? -1 : 1; }
        return this$1._xAxis._getPosition.bind(this$1._xAxis)(d);
      }
    };
    var xRange = this._xAxis._getRange();

    this._yAxis
      .domain(yDomain)
      .height(height)
      .maxSize(width / 2)
      .range([this._xAxis.outerBounds().y + x2Height, height - (xHeight + topOffset + verticalMargin)])
      .scale(yScale.toLowerCase())
      .select(yGroup.node())
      .ticks(yTicks)
      .width(xRange[xRange.length - 1])
      .config(yC)
      .config(this._yConfig)
      .render();

    if (y2Exists) {
      this._y2Axis
        .config(yC)
        .domain(y2Exists ? y2Domain : yDomain)
        .gridSize(0)
        .height(height)
        .range([this._xAxis.outerBounds().y + x2Height, height - (xHeight + topOffset + verticalMargin)])
        .scale(y2Exists ? y2Scale.toLowerCase() : yScale.toLowerCase())
        .select(y2Group.node())
        .width(width - max([0, xOffsetRight - y2Width]))
        .title(false)
        .config(this._y2Config)
        .config(defaultY2Config)
        .render();
    }

    y = function (d, y) {
      if (y === "y2") {
        if (this$1._y2Config.scale === "log" && d === 0) { d = y2Domain[0] < 0 ? -1 : 1; }
        return this$1._y2Axis._getPosition.bind(this$1._y2Axis)(d) - x2Height;
      }
      else {
        if (this$1._yConfig.scale === "log" && d === 0) { d = yDomain[0] < 0 ? -1 : 1; }
        return this$1._yAxis._getPosition.bind(this$1._yAxis)(d) - x2Height;
      }
    };
    var yRange = this._yAxis._getRange();

    var annotationGroup = elem("g.d3plus-plot-annotations", {parent: parent, transition: transition, enter: {transform: transform}, update: {transform: transform}}).node();
    this._annotations.forEach(function (annotation) {
      new shapes[annotation.shape]()
        .config(annotation)
        .config({
          x: function (d) { return d.x2 ? x(d.x2, "x2") : x(d.x); },
          x0: this$1._discrete === "x" ? function (d) { return d.x2 ? x(d.x2, "x2") : x(d.x); } : x(0),
          x1: this$1._discrete === "x" ? null : function (d) { return d.x2 ? x(d.x2, "x2") : x(d.x); },
          y: function (d) { return d.y2 ? y(d.y2, "y2") : y(d.y); },
          y0: this$1._discrete === "y" ? function (d) { return d.y2 ? y(d.y2, "y2") : y(d.y); } : y(0) - yOffset,
          y1: this$1._discrete === "y" ? null : function (d) { return d.y2 ? y(d.y2, "y2") : y(d.y) - yOffset; }
        })
        .select(annotationGroup)
        .render();
    });

    var yOffset = this._xAxis.barConfig()["stroke-width"];
    if (yOffset) { yOffset /= 2; }

    var shapeConfig = {
      duration: this._duration,
      label: function (d) { return this$1._drawLabel(d.data, d.i); },
      select: elem("g.d3plus-plot-shapes", {parent: parent, transition: transition, enter: {transform: transform}, update: {transform: transform}}).node(),
      x: function (d) { return d.x2 ? x(d.x2, "x2") : x(d.x); },
      x0: this._discrete === "x" ? function (d) { return d.x2 ? x(d.x2, "x2") : x(d.x); } : x(0),
      x1: this._discrete === "x" ? null : function (d) { return d.x2 ? x(d.x2, "x2") : x(d.x); },
      y: function (d) { return d.y2 ? y(d.y2, "y2") : y(d.y); },
      y0: this._discrete === "y" ? function (d) { return d.y2 ? y(d.y2, "y2") : y(d.y); } : y(0) - yOffset,
      y1: this._discrete === "y" ? null : function (d) { return d.y2 ? y(d.y2, "y2") : y(d.y) - yOffset; }
    };

    if (this._stacked) {
      var scale = opp === "x" ? x : y;
      shapeConfig[("" + opp)] = shapeConfig[(opp + "0")] = function (d) {
        var dataIndex = stackKeys.indexOf(d.id),
              discreteIndex = discreteKeys.indexOf(d.discrete);
        return dataIndex >= 0 ? scale(stackData[dataIndex][discreteIndex][0]) : scale(0);
      };
      shapeConfig[(opp + "1")] = function (d) {
        var dataIndex = stackKeys.indexOf(d.id),
              discreteIndex = discreteKeys.indexOf(d.discrete);
        return dataIndex >= 0 ? scale(stackData[dataIndex][discreteIndex][1]) : scale(0);
      };
    }

    var events = Object.keys(this._on);
    shapeData.forEach(function (d) {

      var s = new shapes[d.key]().config(shapeConfig).data(d.values);

      if (d.key === "Bar") {

        var space;
        var scale = this$1._discrete === "x" ? x : y;
        var vals = (this$1._discrete === "x" ? xDomain : yDomain).filter(function (d) { return typeof d !== "string" || d.indexOf("d3plus-buffer-") < 0; });
        var range = this$1._discrete === "x" ? xRange : yRange;
        if (vals.length > 1) { space = scale(vals[1]) - scale(vals[0]); }
        else { space = range[range.length - 1] - range[0]; }
        space -= this$1._groupPadding;

        var barSize = space;

        var groups = nest()
          .key(function (d) { return d[this$1._discrete]; })
          .key(function (d) { return d.group; })
          .entries(d.values);

        var ids = merge(groups.map(function (d) { return d.values.map(function (v) { return v.key; }); }));
        var uniqueIds = Array.from(new Set(ids));

        if (max(groups.map(function (d) { return d.values.length; })) === 1) {
          s[this$1._discrete](function (d, i) { return shapeConfig[this$1._discrete](d, i); });
        }
        else {

          barSize = (barSize - this$1._barPadding * uniqueIds.length - 1) / uniqueIds.length;

          var offset = space / 2 - barSize / 2;

          var xMod = scales.scaleLinear()
            .domain([0, uniqueIds.length - 1])
            .range([-offset, offset]);

          s[this$1._discrete](function (d, i) { return shapeConfig[this$1._discrete](d, i) + xMod(uniqueIds.indexOf(d.group)); });

        }

        s.width(barSize);
        s.height(barSize);

      }
      else if (d.key === "Line" && this$1._confidence) {

        var areaConfig = Object.assign({}, shapeConfig);
        var key = this$1._discrete === "x" ? "y" : "x";
        var scaleFunction = this$1._discrete === "x" ? y : x;
        areaConfig[(key + "0")] = function (d) { return scaleFunction(this$1._confidence[0] ? d.lci : d[key]); };
        areaConfig[(key + "1")] = function (d) { return scaleFunction(this$1._confidence[1] ? d.hci : d[key]); };

        var area = new shapes.Area().config(areaConfig).data(d.values);
        var confidenceConfig = Object.assign(this$1._shapeConfig, this$1._confidenceConfig);
        area.config(configPrep.bind(this$1)(confidenceConfig, "shape", "Area")).render();
        this$1._shapes.push(area);
      }

      var classEvents = events.filter(function (e) { return e.includes(("." + (d.key))); }),
            globalEvents = events.filter(function (e) { return !e.includes("."); }),
            shapeEvents = events.filter(function (e) { return e.includes(".shape"); });
      var loop = function ( e ) {
        s.on(globalEvents[e], function (d) { return this$1._on[globalEvents[e]](d.data, d.i); });
      };

      for (var e = 0; e < globalEvents.length; e++) loop( e );
      var loop$1 = function ( e ) {
        s.on(shapeEvents[e], function (d) { return this$1._on[shapeEvents[e]](d.data, d.i); });
      };

      for (var e$1 = 0; e$1 < shapeEvents.length; e$1++) loop$1( e$1 );
      var loop$2 = function ( e ) {
        s.on(classEvents[e], function (d) { return this$1._on[classEvents[e]](d.data, d.i); });
      };

      for (var e$2 = 0; e$2 < classEvents.length; e$2++) loop$2( e$2 );

      s.config(configPrep.bind(this$1)(this$1._shapeConfig, "shape", d.key)).render();
      this$1._shapes.push(s);

    });

    return this;

  };

  /**
      @memberof Plot
      @desc Allows drawing custom shapes to be used as annotations in the provided x/y plot. This method accepts custom config objects for the [Shape](http://d3plus.org/docs/#Shape) class, either a single config object or an array of config objects. Each config object requires an additional parameter, the "shape", which denotes which [Shape](http://d3plus.org/docs/#Shape) sub-class to use ([Rect](http://d3plus.org/docs/#Rect), [Line](http://d3plus.org/docs/#Line), etc). Annotations will be drawn underneath the data to be displayed.
      @param {Array|Object} *annotations* = []
      @chainable
  */
  Plot.prototype.annotations = function annotations (_) {
    return arguments.length ? (this._annotations = _ instanceof Array ? _ : [_], this) : this._annotations;
  };

  /**
      @memberof Plot
      @desc Sets the pixel space between each bar in a group of bars.
      @param {Number} *value* = 0
      @chainable
  */
  Plot.prototype.barPadding = function barPadding (_) {
    return arguments.length ? (this._barPadding = _, this) : this._barPadding;
  };

  /**
      @memberof Plot
      @desc Sets the baseline for the x/y plot. If *value* is not specified, returns the current baseline.
      @param {Number} *value*
      @chainable
  */
  Plot.prototype.baseline = function baseline (_) {
    return arguments.length ? (this._baseline = _, this) : this._baseline;
  };

  /**
       @memberof Plot
       @desc Sets the confidence to the specified array of lower and upper bounds.
       @param {String[]|Function[]} *value*
       @chainable
       @example <caption>Can be called with accessor functions or static keys:</caption>
       var data = {id: "alpha", value: 10, lci: 9, hci: 11};
       ...
       // Accessor functions
       .confidence([function(d) { return d.lci }, function(d) { return d.hci }])

       // Or static keys
       .confidence(["lci", "hci"])
   */
  Plot.prototype.confidence = function confidence (_) {
    if (arguments.length) {
      this._confidence = [];
      var lower = _[0];
      this._confidence[0] = typeof lower === "function" || !lower ? lower : accessor(lower);
      var upper = _[1];
      this._confidence[1] = typeof upper === "function" || !upper ? upper : accessor(upper);

      return this;
    }
    else { return this._confidence; }
  };

  /**
       @memberof Plot
       @desc If *value* is specified, sets the config method for each shape rendered as a confidence interval and returns the current class instance.
       @param {Object} [*value*]
       @chainable
   */
  Plot.prototype.confidenceConfig = function confidenceConfig (_) {
    return arguments.length ? (this._confidenceConfig = assign(this._confidenceConfig, _), this) : this._confidenceConfig;
  };

  /**
      @memberof Plot
      @desc Sets the discrete axis to the specified string. If *value* is not specified, returns the current discrete axis.
      @param {String} *value*
      @chainable
  */
  Plot.prototype.discrete = function discrete (_) {
    return arguments.length ? (this._discrete = _, this) : this._discrete;
  };

  /**
      @memberof Plot
      @desc Sets the pixel space between groups of bars.
      @param {Number} [*value* = 5]
      @chainable
  */
  Plot.prototype.groupPadding = function groupPadding (_) {
    return arguments.length ? (this._groupPadding = _, this) : this._groupPadding;
  };

  /**
      @memberof Plot
      @desc A JavaScript [sort comparator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) that receives each shape Class (ie. "Circle", "Line", etc) as it's comparator arguments. Shapes are drawn in groups based on their type, so you are defining the layering order for all shapes of said type.
      @param {Function} *value*
      @chainable
  */
  Plot.prototype.shapeSort = function shapeSort (_) {
    return arguments.length ? (this._shapeSort = _, this) : this._shapeSort;
  };

  /**
      @memberof Plot
      @desc Sets the size of bubbles to the given Number, data key, or function.
      @param {Function|Number|String} *value* = 10
      @chainable
  */
  Plot.prototype.size = function size (_) {
    return arguments.length ? (this._size = typeof _ === "function" || !_ ? _ : accessor(_), this) : this._size;
  };

  /**
      @memberof Plot
      @desc Sets the size scale maximum to the specified number.
      @param {Number} *value* = 20
      @chainable
  */
  Plot.prototype.sizeMax = function sizeMax (_) {
    return arguments.length ? (this._sizeMax = _, this) : this._sizeMax;
  };

  /**
      @memberof Plot
      @desc Sets the size scale minimum to the specified number.
      @param {Number} *value* = 5
      @chainable
  */
  Plot.prototype.sizeMin = function sizeMin (_) {
    return arguments.length ? (this._sizeMin = _, this) : this._sizeMin;
  };

  /**
      @memberof Plot
      @desc Sets the size scale to the specified string.
      @param {String} *value* = "sqrt"
      @chainable
  */
  Plot.prototype.sizeScale = function sizeScale (_) {
    return arguments.length ? (this._sizeScale = _, this) : this._sizeScale;
  };

  /**
      @memberof Plot
      @desc If *value* is specified, toggles shape stacking. If *value* is not specified, returns the current stack value.
      @param {Boolean} *value* = false
      @chainable
  */
  Plot.prototype.stacked = function stacked (_) {
    return arguments.length ? (this._stacked = _, this) : this._stacked;
  };

  /**
      @memberof Plot
      @desc Sets the stack offset. If *value* is not specified, returns the current stack offset function.
      @param {Function|String} *value* = "descending"
      @chainable
  */
  Plot.prototype.stackOffset = function stackOffset (_) {
    return arguments.length ? (this._stackOffset = typeof _ === "function" ? _ : d3Shape[("stackOffset" + (_.charAt(0).toUpperCase() + _.slice(1)))], this) : this._stackOffset;
  };

  /**
      @memberof Plot
      @desc Sets the stack order. If *value* is not specified, returns the current stack order function.
      @param {Function|String|Array} *value* = "none"
      @chainable
  */
  Plot.prototype.stackOrder = function stackOrder (_) {
    return arguments.length ? (this._stackOrder = typeof _ === "string" ? d3Shape[("stackOrder" + (_.charAt(0).toUpperCase() + _.slice(1)))] : _, this) : this._stackOrder;
  };

  /**
      @memberof Plot
      @desc Sets the x accessor to the specified function or number. If *value* is not specified, returns the current x accessor.
      @param {Function|Number} *value*
      @chainable
  */
  Plot.prototype.x = function x (_) {
    if (arguments.length) {
      if (typeof _ === "function") { this._x = _; }
      else {
        this._x = accessor(_);
        if (!this._aggs[_] && this._discrete === "x") {
          this._aggs[_] = function (a) {
            var v = Array.from(new Set(a));
            return v.length === 1 ? v[0] : v;
          };
        }
      }
      return this;
    }
    else { return this._x; }
  };

  /**
       @memberof Plot
       @desc Sets the x2 accessor to the specified function or number. If *value* is not specified, returns the current x2 accessor.
       @param {Function|Number} *value*
       @chainable
   */
  Plot.prototype.x2 = function x2 (_) {
    if (arguments.length) {
      if (typeof _ === "function") { this._x2 = _; }
      else {
        this._x2 = accessor(_);
        if (!this._aggs[_] && this._discrete === "x") {
          this._aggs[_] = function (a) {
            var v = Array.from(new Set(a));
            return v.length === 1 ? v[0] : v;
          };
        }
      }
      return this;
    }
    else { return this._x2; }
  };

  /**
      @memberof Plot
      @desc Sets the config method for the x-axis. If *value* is not specified, returns the current x-axis configuration.
      @param {Object} *value*
      @chainable
  */
  Plot.prototype.xConfig = function xConfig (_) {
    return arguments.length ? (this._xConfig = assign(this._xConfig, _), this) : this._xConfig;
  };

  /**
      @memberof Plot
      @desc Sets the config method for the secondary x-axis. If *value* is not specified, returns the current secondary x-axis configuration.
      @param {Object} *value*
      @chainable
  */
  Plot.prototype.x2Config = function x2Config (_) {
    return arguments.length ? (this._x2Config = assign(this._x2Config, _), this) : this._x2Config;
  };

  /**
      @memberof Plot
      @desc Sets the x domain to the specified array. If *value* is not specified, returns the current x domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
      @param {Array} *value*
      @chainable
  */
  Plot.prototype.xDomain = function xDomain (_) {
    return arguments.length ? (this._xDomain = _, this) : this._xDomain;
  };

  /**
       @memberof Plot
       @desc Sets the x2 domain to the specified array. If *value* is not specified, returns the current x2 domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
       @param {Array} *value*
       @chainable
   */
  Plot.prototype.x2Domain = function x2Domain (_) {
    return arguments.length ? (this._x2Domain = _, this) : this._x2Domain;
  };

  /**
      @memberof Plot
      @desc Defines a custom sorting comparitor function to be used for discrete x axes.
      @param {Function} *value*
      @chainable
  */
  Plot.prototype.xSort = function xSort (_) {
    return arguments.length ? (this._xSort = _, this) : this._xSort;
  };

  /**
       @memberof Plot
       @desc Defines a custom sorting comparitor function to be used for discrete x2 axes.
       @param {Function} *value*
       @chainable
   */
  Plot.prototype.x2Sort = function x2Sort (_) {
    return arguments.length ? (this._x2Sort = _, this) : this._x2Sort;
  };

  /**
      @memberof Plot
      @desc Sets the y accessor to the specified function or number. If *value* is not specified, returns the current y accessor.
      @param {Function|Number} *value*
      @chainable
  */
  Plot.prototype.y = function y (_) {
    if (arguments.length) {
      if (typeof _ === "function") { this._y = _; }
      else {
        this._y = accessor(_);
        if (!this._aggs[_] && this._discrete === "y") {
          this._aggs[_] = function (a) {
            var v = Array.from(new Set(a));
            return v.length === 1 ? v[0] : v;
          };
        }
      }
      return this;
    }
    else { return this._y; }
  };

  /**
       @memberof Plot
       @desc Sets the y2 accessor to the specified function or number. If *value* is not specified, returns the current y2 accessor.
       @param {Function|Number} *value*
       @chainable
   */
  Plot.prototype.y2 = function y2 (_) {
    if (arguments.length) {
      if (typeof _ === "function") { this._y2 = _; }
      else {
        this._y2 = accessor(_);
        if (!this._aggs[_] && this._discrete === "y2") {
          this._aggs[_] = function (a) {
            var v = Array.from(new Set(a));
            return v.length === 1 ? v[0] : v;
          };
        }
      }
      return this;
    }
    else { return this._y2; }
  };

  /**
      @memberof Plot
      @desc Sets the config method for the y-axis. If *value* is not specified, returns the current y-axis configuration.

*Note:* If a "domain" array is passed to the y-axis config, it will be reversed.
      @param {Object} *value*
      @chainable
  */
  Plot.prototype.yConfig = function yConfig (_) {
    if (arguments.length) {
      if (_.domain) { _.domain = _.domain.slice().reverse(); }
      this._yConfig = assign(this._yConfig, _);
      return this;
    }
    return this._yConfig;
  };

  /**
      @memberof Plot
      @desc Sets the config method for the secondary y-axis. If *value* is not specified, returns the current secondary y-axis configuration.
      @param {Object} *value*
      @chainable
  */
  Plot.prototype.y2Config = function y2Config (_) {
    return arguments.length ? (this._y2Config = assign(this._y2Config, _), this) : this._y2Config;
  };

  /**
      @memberof Plot
      @desc Sets the y domain to the specified array. If *value* is not specified, returns the current y domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
      @param {Array} *value*
      @chainable
  */
  Plot.prototype.yDomain = function yDomain (_) {
    return arguments.length ? (this._yDomain = _, this) : this._yDomain;
  };

  /**
       @memberof Plot
       @desc Sets the y2 domain to the specified array. If *value* is not specified, returns the current y2 domain. Additionally, if either value of the array is undefined, it will be calculated from the data.
       @param {Array} *value*
       @chainable
   */
  Plot.prototype.y2Domain = function y2Domain (_) {
    return arguments.length ? (this._y2Domain = _, this) : this._y2Domain;
  };

  /**
      @memberof Plot
      @desc Defines a custom sorting comparitor function to be used for discrete y axes.
      @param {Function} *value*
      @chainable
  */
  Plot.prototype.ySort = function ySort (_) {
    return arguments.length ? (this._ySort = _, this) : this._ySort;
  };

  /**
       @memberof Plot
       @desc Defines a custom sorting comparitor function to be used for discrete y2 axes.
       @param {Function} *value*
       @chainable
   */
  Plot.prototype.y2Sort = function y2Sort (_) {
    return arguments.length ? (this._y2Sort = _, this) : this._y2Sort;
  };

  return Plot;
}(Viz));

export default Plot;

//# sourceMappingURL=Plot.js.map