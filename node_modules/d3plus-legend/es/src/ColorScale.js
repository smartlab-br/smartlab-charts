function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
    @external BaseClass
    @see https://github.com/d3plus/d3plus-common#BaseClass
*/
import ckmeans from "./ckmeans";
import Legend from "./Legend";
import { extent, merge, range } from "d3-array";
import { scaleLinear, scaleThreshold } from "d3-scale";
import { select as _select } from "d3-selection";
import { Axis } from "d3plus-axis";
import { colorLighter } from "d3plus-color";
import { accessor, assign, BaseClass, constant, elem } from "d3plus-common";
import { Rect } from "d3plus-shape";
/**
    @class ColorScale
    @extends external:BaseClass
    @desc Creates an SVG scale based on an array of data. If *data* is specified, immediately draws based on the specified array and returns the current class instance. If *data* is not specified on instantiation, it can be passed/updated after instantiation using the [data](#shape.data) method.
*/

var ColorScale =
/*#__PURE__*/
function (_BaseClass) {
  _inherits(ColorScale, _BaseClass);

  /**
      @memberof ColorScale
      @desc Invoked when creating a new class instance, and sets any default parameters.
      @private
  */
  function ColorScale() {
    var _this;

    _classCallCheck(this, ColorScale);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ColorScale).call(this));
    _this._axisClass = new Axis();
    _this._axisConfig = {
      gridSize: 0,
      shapeConfig: {
        labelConfig: {
          fontColor: "#222"
        }
      },
      titleConfig: {
        fontSize: 12
      }
    };
    _this._axisTest = new Axis();
    _this._align = "middle";
    _this._bucketAxis = false;
    _this._color = "#0C8040";
    _this._data = [];
    _this._duration = 600;
    _this._height = 200;
    _this._legendClass = new Legend();
    _this._legendConfig = {
      shapeConfig: {
        labelConfig: {
          fontColor: "#222"
        },
        stroke: "#444",
        strokeWidth: 1
      }
    };
    _this._orient = "bottom";
    _this._outerBounds = {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    _this._padding = 5;
    _this._rectClass = new Rect();
    _this._rectConfig = {
      stroke: "#444",
      strokeWidth: 1
    };
    _this._scale = "linear";
    _this._size = 10;
    _this._value = accessor("value");
    _this._width = 400;
    return _this;
  }
  /**
      @memberof ColorScale
      @desc Renders the current ColorScale to the page. If a *callback* is specified, it will be called once the ColorScale is done drawing.
      @param {Function} [*callback* = undefined]
      @chainable
  */


  _createClass(ColorScale, [{
    key: "render",
    value: function render(callback) {
      var _this2 = this;

      if (this._select === void 0) this.select(_select("body").append("svg").attr("width", "".concat(this._width, "px")).attr("height", "".concat(this._height, "px")).node());
      var horizontal = ["bottom", "top"].includes(this._orient);
      var height = horizontal ? "height" : "width",
          width = horizontal ? "width" : "height",
          x = horizontal ? "x" : "y",
          y = horizontal ? "y" : "x"; // Shape <g> Group

      this._group = elem("g.d3plus-ColorScale", {
        parent: this._select
      });
      var domain = extent(this._data, this._value);
      var colors = this._color,
          labels,
          ticks;

      if (!(colors instanceof Array)) {
        colors = [colorLighter(colors, 0.9), colorLighter(colors, 0.75), colorLighter(colors, 0.5), colorLighter(colors, 0.25), colors];
      }

      if (this._scale === "jenks") {
        var data = this._data.map(this._value).filter(function (d) {
          return d !== null && typeof d === "number";
        });

        if (data.length <= colors.length) {
          colors = colors.slice(colors.length - data.length);
        }

        var jenks = ckmeans(data, colors.length);
        ticks = merge(jenks.map(function (c, i) {
          return i === jenks.length - 1 ? [c[0], c[c.length - 1]] : [c[0]];
        }));
        var tickSet = new Set(ticks);

        if (ticks.length !== tickSet.size) {
          labels = Array.from(tickSet);
        }

        this._colorScale = scaleThreshold().domain(ticks).range(["black"].concat(colors).concat(colors[colors.length - 1]));
      } else {
        var step = (domain[1] - domain[0]) / (colors.length - 1);
        var buckets = range(domain[0], domain[1] + step / 2, step);
        if (this._scale === "buckets") ticks = buckets;
        this._colorScale = scaleLinear().domain(buckets).range(colors);
      }

      if (this._bucketAxis || !["buckets", "jenks"].includes(this._scale)) {
        var _this$_rectClass$data;

        var axisConfig = assign({
          domain: horizontal ? domain : domain.reverse(),
          duration: this._duration,
          height: this._height,
          labels: labels || ticks,
          orient: this._orient,
          padding: this._padding,
          ticks: ticks,
          width: this._width
        }, this._axisConfig);

        this._axisTest.select(elem("g.d3plus-ColorScale-axisTest", {
          enter: {
            opacity: 0
          },
          parent: this._group
        }).node()).config(axisConfig).duration(0).render();

        var axisBounds = this._axisTest.outerBounds();

        this._outerBounds[width] = this["_".concat(width)] - this._padding * 2;
        this._outerBounds[height] = axisBounds[height] + this._size;
        this._outerBounds[x] = this._padding;
        this._outerBounds[y] = this._padding;
        if (this._align === "middle") this._outerBounds[y] = (this["_".concat(height)] - this._outerBounds[height]) / 2;else if (this._align === "end") this._outerBounds[y] = this["_".concat(height)] - this._padding - this._outerBounds[height];

        var groupOffset = this._outerBounds[y] + (["bottom", "right"].includes(this._orient) ? this._size : 0) - (axisConfig.padding || this._axisClass.padding());

        this._axisClass.select(elem("g.d3plus-ColorScale-axis", {
          parent: this._group,
          update: {
            transform: "translate(".concat(horizontal ? 0 : groupOffset, ", ").concat(horizontal ? groupOffset : 0, ")")
          }
        }).node()).config(axisConfig).align("start").render();

        var axisScale = this._axisTest._getPosition.bind(this._axisTest);

        var scaleRange = this._axisTest._getRange();

        var defs = this._group.selectAll("defs").data([0]);

        var defsEnter = defs.enter().append("defs");
        defsEnter.append("linearGradient").attr("id", "gradient-".concat(this._uuid));
        defs = defsEnter.merge(defs);
        defs.select("linearGradient").attr("".concat(x, "1"), horizontal ? "0%" : "100%").attr("".concat(x, "2"), horizontal ? "100%" : "0%").attr("".concat(y, "1"), "0%").attr("".concat(y, "2"), "0%");
        var stops = defs.select("linearGradient").selectAll("stop").data(colors);
        stops.enter().append("stop").merge(stops).attr("offset", function (d, i) {
          return "".concat(i / (colors.length - 1) * 100, "%");
        }).attr("stop-color", String);
        /** determines the width of buckets */

        var bucketWidth = function bucketWidth(d, i) {
          var w = Math.abs(axisScale(ticks[i + 1]) - axisScale(d));
          return w || 2;
        };

        this._rectClass.data(ticks ? ticks.slice(0, ticks.length - 1) : [0]).id(function (d, i) {
          return i;
        }).select(elem("g.d3plus-ColorScale-Rect", {
          parent: this._group
        }).node()).config((_this$_rectClass$data = {
          duration: this._duration,
          fill: ticks ? function (d) {
            return _this2._colorScale(d);
          } : "url(#gradient-".concat(this._uuid, ")")
        }, _defineProperty(_this$_rectClass$data, x, ticks ? function (d, i) {
          return axisScale(d) + bucketWidth(d, i) / 2 - (["left", "right"].includes(_this2._orient) ? bucketWidth(d, i) : 0);
        } : scaleRange[0] + (scaleRange[1] - scaleRange[0]) / 2), _defineProperty(_this$_rectClass$data, y, this._outerBounds[y] + (["top", "left"].includes(this._orient) ? axisBounds[height] : 0) + this._size / 2), _defineProperty(_this$_rectClass$data, width, ticks ? bucketWidth : scaleRange[1] - scaleRange[0]), _defineProperty(_this$_rectClass$data, height, this._size), _this$_rectClass$data)).config(this._rectConfig).render();
      } else {
        var format = this._axisConfig.tickFormat ? this._axisConfig.tickFormat : function (d) {
          return d;
        };

        var _data = ticks.reduce(function (arr, tick, i) {
          if (i !== ticks.length - 1) {
            var next = ticks[i + 1];
            arr.push({
              color: colors[i],
              id: tick === next ? "".concat(format(tick), "+") : "".concat(format(tick), " - ").concat(format(next))
            });
          }

          return arr;
        }, []);

        var legendConfig = assign({
          align: horizontal ? "center" : {
            start: "left",
            middle: "center",
            end: "right"
          }[this._align],
          direction: horizontal ? "row" : "column",
          duration: this._duration,
          height: this._height,
          padding: this._padding,
          shapeConfig: assign({
            duration: this._duration
          }, this._axisConfig.shapeConfig || {}),
          title: this._axisConfig.title,
          titleConfig: this._axisConfig.titleConfig || {},
          width: this._width,
          verticalAlign: horizontal ? {
            start: "top",
            middle: "middle",
            end: "bottom"
          }[this._align] : "middle"
        }, this._legendConfig);

        this._legendClass.data(_data).select(elem("g.d3plus-ColorScale-legend", {
          parent: this._group
        }).node()).config(legendConfig).render();

        this._outerBounds = this._legendClass.outerBounds();
      }

      if (callback) setTimeout(callback, this._duration + 100);
      return this;
    }
    /**
        @memberof ColorScale
        @desc The [ColorScale](http://d3plus.org/docs/#ColorScale) is constructed by combining an [Axis](http://d3plus.org/docs/#Axis) for the ticks/labels and a [Rect](http://d3plus.org/docs/#Rect) for the actual color box (or multiple boxes, as in a jenks scale). Because of this, there are separate configs for the [Axis](http://d3plus.org/docs/#Axis) class used to display the text ([axisConfig](http://d3plus.org/docs/#ColorScale.axisConfig)) and the [Rect](http://d3plus.org/docs/#Rect) class used to draw the color breaks ([rectConfig](http://d3plus.org/docs/#ColorScale.rectConfig)). This method acts as a pass-through to the config method of the [Axis](http://d3plus.org/docs/#Axis). An example usage of this method can be seen [here](http://d3plus.org/examples/d3plus-legend/colorScale-dark/).
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "axisConfig",
    value: function axisConfig(_) {
      return arguments.length ? (this._axisConfig = assign(this._axisConfig, _), this) : this._axisConfig;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the horizontal alignment to the specified value and returns the current class instance. If *value* is not specified, returns the current horizontal alignment.
        @param {String} [*value* = "center"] Supports `"left"` and `"center"` and `"right"`.
        @chainable
    */

  }, {
    key: "align",
    value: function align(_) {
      return arguments.length ? (this._align = _, this) : this._align;
    }
    /**
        @memberof ColorScale
        @desc Determines whether or not to use an Axis to display bucket scales (both "buckets" and "jenks"). When set to `false`, bucketed scales will use the `Legend` class to display squares for each range of data. When set to `true`, bucketed scales will be displayed on an `Axis`, similar to "linear" scales.
        @param {Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "bucketAxis",
    value: function bucketAxis(_) {
      return arguments.length ? (this._bucketAxis = _, this) : this._bucketAxis;
    }
    /**
        @memberof ColorScale
        @desc Defines the color or colors to be used for the scale. If only a single color is given as a String, then the scale is interpolated by lightening that color. Otherwise, the function expects an Array of color values to be used in order for the scale.
        @param {String|Array} [*value* = "#0C8040"]
        @chainable
    */

  }, {
    key: "color",
    value: function color(_) {
      return arguments.length ? (this._color = _, this) : this._color;
    }
    /**
        @memberof ColorScale
        @desc If *data* is specified, sets the data array to the specified array and returns the current class instance. If *data* is not specified, returns the current data array. A shape key will be drawn for each object in the array.
        @param {Array} [*data* = []]
        @chainable
    */

  }, {
    key: "data",
    value: function data(_) {
      return arguments.length ? (this._data = _, this) : this._data;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the transition duration of the ColorScale and returns the current class instance. If *value* is not specified, returns the current duration.
        @param {Number} [*value* = 600]
        @chainable
    */

  }, {
    key: "duration",
    value: function duration(_) {
      return arguments.length ? (this._duration = _, this) : this._duration;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the overall height of the ColorScale and returns the current class instance. If *value* is not specified, returns the current height value.
        @param {Number} [*value* = 100]
        @chainable
    */

  }, {
    key: "height",
    value: function height(_) {
      return arguments.length ? (this._height = _, this) : this._height;
    }
    /**
        @memberof ColorScale
        @desc The [ColorScale](http://d3plus.org/docs/#ColorScale) is constructed by combining an [Axis](http://d3plus.org/docs/#Axis) for the ticks/labels and a [Rect](http://d3plus.org/docs/#Rect) for the actual color box (or multiple boxes, as in a jenks scale). Because of this, there are separate configs for the [Axis](http://d3plus.org/docs/#Axis) class used to display the text ([axisConfig](http://d3plus.org/docs/#ColorScale.axisConfig)) and the [Rect](http://d3plus.org/docs/#Rect) class used to draw the color breaks ([rectConfig](http://d3plus.org/docs/#ColorScale.rectConfig)). This method acts as a pass-through to the config method of the [Axis](http://d3plus.org/docs/#Axis). An example usage of this method can be seen [here](http://d3plus.org/examples/d3plus-legend/colorScale-dark/).
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "legendConfig",
    value: function legendConfig(_) {
      return arguments.length ? (this._legendConfig = assign(this._legendConfig, _), this) : this._legendConfig;
    }
    /**
        @memberof ColorScale
        @desc Sets the flow of the items inside the ColorScale. If no value is passed, the current flow will be returned.
        @param {String} [*value* = "bottom"]
        @chainable
    */

  }, {
    key: "orient",
    value: function orient(_) {
      return arguments.length ? (this._orient = _, this) : this._orient;
    }
    /**
        @memberof ColorScale
        @desc If called after the elements have been drawn to DOM, will returns the outer bounds of the ColorScale content.
        @example
    {"width": 180, "height": 24, "x": 10, "y": 20}
    */

  }, {
    key: "outerBounds",
    value: function outerBounds() {
      return this._outerBounds;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the padding between each key to the specified number and returns the current class instance. If *value* is not specified, returns the current padding value.
        @param {Number} [*value* = 10]
        @chainable
    */

  }, {
    key: "padding",
    value: function padding(_) {
      return arguments.length ? (this._padding = _, this) : this._padding;
    }
    /**
        @memberof ColorScale
        @desc The [ColorScale](http://d3plus.org/docs/#ColorScale) is constructed by combining an [Axis](http://d3plus.org/docs/#Axis) for the ticks/labels and a [Rect](http://d3plus.org/docs/#Rect) for the actual color box (or multiple boxes, as in a jenks scale). Because of this, there are separate configs for the [Axis](http://d3plus.org/docs/#Axis) class used to display the text ([axisConfig](http://d3plus.org/docs/#ColorScale.axisConfig)) and the [Rect](http://d3plus.org/docs/#Rect) class used to draw the color breaks ([rectConfig](http://d3plus.org/docs/#ColorScale.rectConfig)). This method acts as a pass-through to the config method of the [Rect](http://d3plus.org/docs/#Rect). An example usage of this method can be seen [here](http://d3plus.org/examples/d3plus-legend/colorScale-dark/).
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "rectConfig",
    value: function rectConfig(_) {
      return arguments.length ? (this._rectConfig = assign(this._rectConfig, _), this) : this._rectConfig;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the scale of the ColorScale and returns the current class instance. If *value* is not specified, returns the current scale value.
        @param {String} [*value* = "linear"] Can either be "linear", "jenks", or "buckets".
        @chainable
    */

  }, {
    key: "scale",
    value: function scale(_) {
      return arguments.length ? (this._scale = _, this) : this._scale;
    }
    /**
        @memberof ColorScale
        @desc If *selector* is specified, sets the SVG container element to the specified d3 selector or DOM element and returns the current class instance. If *selector* is not specified, returns the current SVG container element.
        @param {String|HTMLElement} [*selector* = d3.select("body").append("svg")]
        @chainable
    */

  }, {
    key: "select",
    value: function select(_) {
      return arguments.length ? (this._select = _select(_), this) : this._select;
    }
    /**
        @memberof ColorScale
        @desc The height of horizontal color scales, and width when positioned vertical.
        @param {Number} [*value* = 10]
        @chainable
    */

  }, {
    key: "size",
    value: function size(_) {
      return arguments.length ? (this._size = _, this) : this._size;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the value accessor to the specified function or string and returns the current class instance. If *value* is not specified, returns the current value accessor.
        @param {Function|String} [*value*]
        @chainable
        @example
    function value(d) {
    return d.value;
    }
    */

  }, {
    key: "value",
    value: function value(_) {
      return arguments.length ? (this._value = typeof _ === "function" ? _ : constant(_), this) : this._value;
    }
    /**
        @memberof ColorScale
        @desc If *value* is specified, sets the overall width of the ColorScale and returns the current class instance. If *value* is not specified, returns the current width value.
        @param {Number} [*value* = 400]
        @chainable
    */

  }, {
    key: "width",
    value: function width(_) {
      return arguments.length ? (this._width = _, this) : this._width;
    }
  }]);

  return ColorScale;
}(BaseClass);

export { ColorScale as default };