function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
    @external BaseClass
    @see https://github.com/d3plus/d3plus-common#BaseClass
*/
import { extent, max, min, range as d3Range, ticks as d3Ticks } from "d3-array";
import { timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond } from "d3-time";
import { timeFormat, timeFormatDefaultLocale } from "d3-time-format";
import * as scales from "d3-scale";
import { select as _select } from "d3-selection";
import { transition } from "d3-transition";
import { assign, attrize, BaseClass, closest, constant, elem } from "d3plus-common";
import { formatAbbreviate, formatLocale } from "d3plus-format";
import * as shapes from "d3plus-shape";
import { rtl as detectRTL, TextBox, textWrap } from "d3plus-text";
import { default as date } from "./date";
import { default as locale } from "./locale";
/**
    @class Axis
    @extends external:BaseClass
    @desc Creates an SVG scale based on an array of data.
*/

var Axis =
/*#__PURE__*/
function (_BaseClass) {
  _inherits(Axis, _BaseClass);

  /**
      @memberof Axis
      @desc Invoked when creating a new class instance, and sets any default parameters.
      @private
  */
  function Axis() {
    var _this;

    _classCallCheck(this, Axis);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Axis).call(this));
    _this._align = "middle";
    _this._barConfig = {
      "stroke": "#000",
      "stroke-width": 1
    };
    _this._domain = [0, 10];
    _this._duration = 600;
    _this._gridConfig = {
      "stroke": "#ccc",
      "stroke-width": 1
    };
    _this._gridLog = false;
    _this._height = 400;
    _this._labelOffset = true;

    _this.orient("bottom");

    _this._outerBounds = {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    _this._padding = 5;
    _this._paddingInner = 0.1;
    _this._paddingOuter = 0.1;
    _this._rotateLabels = false;
    _this._scale = "linear";
    _this._scalePadding = 0.5;
    _this._shape = "Line";
    _this._shapeConfig = {
      fill: "#000",
      height: function height(d) {
        return d.tick ? 8 : 0;
      },
      label: function label(d) {
        return d.text;
      },
      labelBounds: function labelBounds(d) {
        return d.labelBounds;
      },
      labelConfig: {
        fontColor: "#000",
        fontFamily: new TextBox().fontFamily(),
        fontResize: false,
        fontSize: constant(10),
        padding: 0,
        textAnchor: function textAnchor() {
          var rtl = detectRTL();
          return _this._orient === "left" ? rtl ? "start" : "end" : _this._orient === "right" ? rtl ? "end" : "start" : _this._rotateLabels ? _this._orient === "bottom" ? "end" : "start" : "middle";
        },
        verticalAlign: function verticalAlign() {
          return _this._orient === "bottom" ? "top" : _this._orient === "top" ? "bottom" : "middle";
        }
      },
      r: function r(d) {
        return d.tick ? 4 : 0;
      },
      stroke: "#000",
      strokeWidth: 1,
      width: function width(d) {
        return d.tick ? 8 : 0;
      }
    };
    _this._tickSize = 5;
    _this._tickSpecifier = undefined;
    _this._tickSuffix = "normal";
    _this._tickUnit = 0;
    _this._timeLocale = undefined;
    _this._titleClass = new TextBox();
    _this._titleConfig = {
      fontSize: 12,
      textAnchor: "middle"
    };
    _this._width = 400;
    return _this;
  }
  /**
      @memberof Axis
      @desc Sets positioning for the axis bar.
      @param {D3Selection} *bar*
      @private
  */


  _createClass(Axis, [{
    key: "_barPosition",
    value: function _barPosition(bar) {
      var _this$_position = this._position,
          height = _this$_position.height,
          x = _this$_position.x,
          y = _this$_position.y,
          opposite = _this$_position.opposite,
          domain = this._getDomain(),
          offset = this._margin[opposite],
          position = ["top", "left"].includes(this._orient) ? this._outerBounds[y] + this._outerBounds[height] - offset : this._outerBounds[y] + offset;

      var x1mod = this._scale === "band" ? this._d3Scale.step() - this._d3Scale.bandwidth() : this._scale === "point" ? this._d3Scale.step() * this._d3Scale.padding() : 0;
      var x2mod = this._scale === "band" ? this._d3Scale.step() : this._scale === "point" ? this._d3Scale.step() * this._d3Scale.padding() : 0;
      bar.call(attrize, this._barConfig).attr("".concat(x, "1"), this._getPosition(domain[0]) - x1mod).attr("".concat(x, "2"), this._getPosition(domain[domain.length - 1]) + x2mod).attr("".concat(y, "1"), position).attr("".concat(y, "2"), position);
    }
    /**
        @memberof Axis
        @desc Returns the scale's domain, taking into account negative and positive log scales.
        @private
    */

  }, {
    key: "_getDomain",
    value: function _getDomain() {
      var ticks = [];
      if (this._d3ScaleNegative) ticks = this._d3ScaleNegative.domain();
      if (this._d3Scale) ticks = ticks.concat(this._d3Scale.domain());
      var domain = ["band", "ordinal", "point"].includes(this._scale) ? ticks : extent(ticks);
      return ticks[0] > ticks[1] ? domain.reverse() : domain;
    }
    /**
        @memberof Axis
        @desc Returns a value's scale position, taking into account negative and positive log scales.
        @param {Number|String} *d*
        @private
    */

  }, {
    key: "_getPosition",
    value: function _getPosition(d) {
      return d < 0 && this._d3ScaleNegative ? this._d3ScaleNegative(d) : this._d3Scale(d);
    }
    /**
        @memberof Axis
        @desc Returns the scale's range, taking into account negative and positive log scales.
        @private
    */

  }, {
    key: "_getRange",
    value: function _getRange() {
      var ticks = [];
      if (this._d3ScaleNegative) ticks = this._d3ScaleNegative.range();
      if (this._d3Scale) ticks = ticks.concat(this._d3Scale.range());
      return ticks[0] > ticks[1] ? extent(ticks).reverse() : extent(ticks);
    }
    /**
        @memberof Axis
        @desc Returns the scale's ticks, taking into account negative and positive log scales.
        @private
    */

  }, {
    key: "_getTicks",
    value: function _getTicks() {
      var tickScale = scales.scaleSqrt().domain([10, 400]).range([10, 50]);
      var ticks = [];

      if (this._d3ScaleNegative) {
        var negativeRange = this._d3ScaleNegative.range();

        var size = negativeRange[1] - negativeRange[0];
        ticks = this._d3ScaleNegative.ticks(Math.floor(size / tickScale(size)));
      }

      if (this._d3Scale) {
        var positiveRange = this._d3Scale.range();

        var _size = positiveRange[1] - positiveRange[0];

        ticks = ticks.concat(this._d3Scale.ticks(Math.floor(_size / tickScale(_size))));
      }

      return ticks;
    }
    /**
        @memberof Axis
        @desc Sets positioning for the grid lines.
        @param {D3Selection} *lines*
        @private
    */

  }, {
    key: "_gridPosition",
    value: function _gridPosition(lines) {
      var last = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var _this$_position2 = this._position,
          height = _this$_position2.height,
          x = _this$_position2.x,
          y = _this$_position2.y,
          opposite = _this$_position2.opposite,
          offset = this._margin[opposite],
          position = ["top", "left"].includes(this._orient) ? this._outerBounds[y] + this._outerBounds[height] - offset : this._outerBounds[y] + offset,
          scale = last ? this._lastScale || this._getPosition.bind(this) : this._getPosition.bind(this),
          size = ["top", "left"].includes(this._orient) ? offset : -offset,
          xDiff = this._scale === "band" ? this._d3Scale.bandwidth() / 2 : 0,
          xPos = function xPos(d) {
        return scale(d.id) + xDiff;
      };

      lines.call(attrize, this._gridConfig).attr("".concat(x, "1"), xPos).attr("".concat(x, "2"), xPos).attr("".concat(y, "1"), position).attr("".concat(y, "2"), last ? position : position + size);
    }
    /**
        @memberof Axis
        @desc Renders the current Axis to the page. If a *callback* is specified, it will be called once the legend is done drawing.
        @param {Function} [*callback* = undefined]
        @chainable
    */

  }, {
    key: "render",
    value: function render(callback) {
      var _this3 = this,
          _this$_outerBounds;

      /**
       * Creates an SVG element to contain the axis if none
       * has been specified using the "select" method.
       */
      if (this._select === void 0) {
        this.select(_select("body").append("svg").attr("width", "".concat(this._width, "px")).attr("height", "".concat(this._height, "px")).node());
      }

      var timeLocale = this._timeLocale || locale[this._locale] || locale["en-US"];
      timeFormatDefaultLocale(timeLocale).format();
      var formatDay = timeFormat("%a %d"),
          formatHour = timeFormat("%I %p"),
          formatMillisecond = timeFormat(".%L"),
          formatMinute = timeFormat("%I:%M"),
          formatMonth = timeFormat("%b"),
          formatSecond = timeFormat(":%S"),
          formatWeek = timeFormat("%b %d"),
          formatYear = timeFormat("%Y");
      /**
       * Declares some commonly used variables.
       */

      var _this$_position3 = this._position,
          width = _this$_position3.width,
          height = _this$_position3.height,
          x = _this$_position3.x,
          y = _this$_position3.y,
          horizontal = _this$_position3.horizontal,
          opposite = _this$_position3.opposite,
          clipId = "d3plus-Axis-clip-".concat(this._uuid),
          flip = ["top", "left"].includes(this._orient),
          p = this._padding,
          parent = this._select,
          rangeOuter = [p, this["_".concat(width)] - p],
          t = transition().duration(this._duration);
      var tickValue = this._shape === "Circle" ? this._shapeConfig.r : this._shape === "Rect" ? this._shapeConfig[width] : this._shapeConfig.strokeWidth;
      var tickGet = typeof tickValue !== "function" ? function () {
        return tickValue;
      } : tickValue;
      /**
       * Zeros out the margins for re-calculation.
       */

      var margin = this._margin = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
      var labels, range, ticks;
      /**
       * (Re)calculates the internal d3 scale
       * @param {} newRange
       */

      function setScale() {
        var _this2 = this;

        var newRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._range;

        /**
         * Calculates the internal "range" array to use, including
         * fallbacks if not specified with the "range" method.
         */
        range = newRange ? newRange.slice() : [undefined, undefined];
        var minRange = rangeOuter[0],
            maxRange = rangeOuter[1];

        if (this._range) {
          if (this._range[0] !== undefined) minRange = this._range[0];
          if (this._range[this._range.length - 1] !== undefined) maxRange = this._range[this._range.length - 1];
        }

        if (range[0] === undefined || range[0] < minRange) range[0] = minRange;
        if (range[1] === undefined || range[1] > maxRange) range[1] = maxRange;
        var sizeInner = maxRange - minRange;

        if (this._scale === "ordinal" && this._domain.length > range.length) {
          if (newRange === this._range) {
            var buckets = this._domain.length + 1;
            range = d3Range(buckets).map(function (d) {
              return range[0] + sizeInner * (d / (buckets - 1));
            }).slice(1, buckets);
            range = range.map(function (d) {
              return d - range[0] / 2;
            });
          } else {
            var _buckets = this._domain.length;
            var size = range[1] - range[0];
            range = d3Range(_buckets).map(function (d) {
              return range[0] + size * (d / (_buckets - 1));
            });
          }
        } else if (newRange === this._range) {
          var tickScale = scales.scaleSqrt().domain([10, 400]).range([10, 50]);
          var domain = this._scale === "time" ? this._domain.map(date) : this._domain;
          var scaleTicks = d3Ticks(domain[0], domain[1], Math.floor(sizeInner / tickScale(sizeInner)));
          ticks = (this._ticks ? this._scale === "time" ? this._ticks.map(date) : this._ticks : scaleTicks).slice();
          labels = (this._labels ? this._scale === "time" ? this._labels.map(date) : this._labels : scaleTicks).slice();
          var _buckets2 = labels.length;

          if (_buckets2) {
            var pad = Math.ceil(sizeInner / _buckets2 / 2);
            range = [range[0] + pad, range[1] - pad];
          }
        }
        /**
         * Sets up the initial d3 scale, using this._domain and the
         * previously defined range variable.
         */


        this._d3Scale = scales["scale".concat(this._scale.charAt(0).toUpperCase()).concat(this._scale.slice(1))]().domain(this._scale === "time" ? this._domain.map(date) : this._domain);
        if (this._d3Scale.round) this._d3Scale.round(true);
        if (this._d3Scale.padding) this._d3Scale.padding(this._scalePadding);
        if (this._d3Scale.paddingInner) this._d3Scale.paddingInner(this._paddingInner);
        if (this._d3Scale.paddingOuter) this._d3Scale.paddingOuter(this._paddingOuter);
        if (this._d3Scale.rangeRound) this._d3Scale.rangeRound(range);else this._d3Scale.range(range);
        /**
         * Constructs a separate "negative only" scale for logarithmic
         * domains, as they cannot pass zero.
         */

        this._d3ScaleNegative = null;

        if (this._scale === "log") {
          var _domain = this._d3Scale.domain();

          if (_domain[0] === 0) _domain[0] = 1;
          if (_domain[_domain.length - 1] === 0) _domain[_domain.length - 1] = -1;

          var _range = this._d3Scale.range();

          if (_domain[0] < 0 && _domain[_domain.length - 1] < 0) {
            this._d3ScaleNegative = this._d3Scale.copy().domain(_domain).range(_range);
            this._d3Scale = null;
          } else if (_domain[0] > 0 && _domain[_domain.length - 1] > 0) {
            this._d3Scale.domain(_domain).range(_range);
          } else {
            var percentScale = scales.scaleLog().domain([1, _domain[_domain[1] > 0 ? 1 : 0]]).range([0, 1]);
            var leftPercentage = percentScale(Math.abs(_domain[_domain[1] < 0 ? 1 : 0]));
            var zero = leftPercentage / (leftPercentage + 1) * (_range[1] - _range[0]);
            if (_domain[0] > 0) zero = _range[1] - _range[0] - zero;
            this._d3ScaleNegative = this._d3Scale.copy();
            (_domain[0] < 0 ? this._d3Scale : this._d3ScaleNegative).domain([Math.sign(_domain[1]), _domain[1]]).range([_range[0] + zero, _range[1]]);
            (_domain[0] < 0 ? this._d3ScaleNegative : this._d3Scale).domain([_domain[0], Math.sign(_domain[0])]).range([_range[0], _range[0] + zero]);
          }
        }
        /**
         * Determines the of values array to use
         * for the "ticks" and the "labels"
         */


        ticks = (this._ticks ? this._scale === "time" ? this._ticks.map(date) : this._ticks : (this._d3Scale ? this._d3Scale.ticks : this._d3ScaleNegative.ticks) ? this._getTicks() : this._domain).slice();
        labels = (this._labels ? this._scale === "time" ? this._labels.map(date) : this._labels : (this._d3Scale ? this._d3Scale.ticks : this._d3ScaleNegative.ticks) ? this._getTicks() : ticks).slice();

        if (this._scale === "log") {
          labels = labels.filter(function (t) {
            return Math.abs(t).toString().charAt(0) === "1" && (_this2._d3Scale ? t !== -1 : t !== 1);
          });
        } else if (this._scale === "time") {
          ticks = ticks.map(Number);
          labels = labels.map(Number);
        }

        ticks = ticks.sort(function (a, b) {
          return _this2._getPosition(a) - _this2._getPosition(b);
        });
        labels = labels.sort(function (a, b) {
          return _this2._getPosition(a) - _this2._getPosition(b);
        });
        /**
         * Get the smallest suffix.
         */

        if (this._scale === "linear" && this._tickSuffix === "smallest") {
          var suffixes = labels.filter(function (d) {
            return d >= 1000;
          });

          if (suffixes.length > 0) {
            var _min = Math.min.apply(Math, _toConsumableArray(suffixes));

            var i = 1;

            while (i && i < 7) {
              var n = Math.pow(10, 3 * i);

              if (_min / n >= 1) {
                this._tickUnit = i;
                i += 1;
              } else {
                break;
              }
            }
          }
        }
        /**
         * Removes ticks when they overlap other ticks.
         */


        var pixels = [];
        this._availableTicks = ticks;
        ticks.forEach(function (d, i) {
          var s = tickGet({
            id: d,
            tick: true
          }, i);
          if (_this2._shape === "Circle") s *= 2;

          var t = _this2._getPosition(d);

          if (!pixels.length || Math.abs(closest(t, pixels) - t) > s * 2) pixels.push(t);else pixels.push(false);
        });
        ticks = ticks.filter(function (d, i) {
          return pixels[i] !== false;
        });
        this._visibleTicks = ticks;
      }

      setScale.bind(this)();
      /**
       * Calculates the space available for a given label.
       * @param {Object} datum
       */

      function calculateSpace(datum) {
        var diff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var i = datum.i,
            position = datum.position;

        if (this._scale === "band") {
          return this._d3Scale.bandwidth();
        } else {
          var prevPosition = i - diff < 0 ? rangeOuter[0] : position - (position - textData[i - diff].position) / 2;
          var prevSpace = Math.abs(position - prevPosition);
          var nextPosition = i + diff > textData.length - 1 ? rangeOuter[1] : position - (position - textData[i + diff].position) / 2;
          var nextSpace = Math.abs(position - nextPosition);
          return min([prevSpace, nextSpace]) * 2;
        }
      }
      /**
       * Constructs the tick formatter function.
       */


      var tickFormat = this._tickFormat ? this._tickFormat : function (d) {
        if (_this3._scale === "log") {
          var _p = Math.round(Math.log(Math.abs(d)) / Math.LN10);

          var _t = Math.abs(d).toString().charAt(0);

          var _n = "10 ".concat("".concat(_p).split("").map(function (c) {
            return "⁰¹²³⁴⁵⁶⁷⁸⁹"[c];
          }).join(""));

          if (_t !== "1") _n = "".concat(_t, " x ").concat(_n);
          return d < 0 ? "-".concat(_n) : _n;
        } else if (_this3._scale === "time") {
          return (timeSecond(d) < d ? formatMillisecond : timeMinute(d) < d ? formatSecond : timeHour(d) < d ? formatMinute : timeDay(d) < d ? formatHour : timeMonth(d) < d ? timeWeek(d) < d ? formatDay : formatWeek : timeYear(d) < d ? formatMonth : formatYear)(d);
        } else if (["band", "ordinal", "point"].includes(_this3._scale)) {
          return d;
        }

        var n = _this3._d3Scale.tickFormat ? _this3._d3Scale.tickFormat(labels.length - 1)(d) : d;
        n = n.replace(/[^\d\.\-\+]/g, "") * 1;

        if (isNaN(n)) {
          return n;
        } else if (_this3._scale === "linear" && _this3._tickSuffix === "smallest") {
          var _locale = _typeof(_this3._locale) === "object" ? _this3._locale : formatLocale[_this3._locale];

          var separator = _locale.separator,
              suffixes = _locale.suffixes;
          var suff = n >= 1000 ? suffixes[_this3._tickUnit + 8] : "";
          var tick = n / Math.pow(10, 3 * _this3._tickUnit);
          var number = formatAbbreviate(tick, _locale, ",.".concat(tick.toString().length, "r"));
          return "".concat(number).concat(separator).concat(suff);
        } else {
          return formatAbbreviate(n, _this3._locale);
        }
      };
      /**
       * Pre-calculates the size of the title, if defined, in order
       * to adjust the internal margins.
       */

      if (this._title) {
        var _this$_titleConfig = this._titleConfig,
            fontFamily = _this$_titleConfig.fontFamily,
            fontSize = _this$_titleConfig.fontSize,
            lineHeight = _this$_titleConfig.lineHeight;
        var titleWrap = textWrap().fontFamily(typeof fontFamily === "function" ? fontFamily() : fontFamily).fontSize(typeof fontSize === "function" ? fontSize() : fontSize).lineHeight(typeof lineHeight === "function" ? lineHeight() : lineHeight).width(range[range.length - 1] - range[0] - p * 2).height(this["_".concat(height)] - this._tickSize - p * 2);
        var lines = titleWrap(this._title).lines.length;
        margin[this._orient] = lines * titleWrap.lineHeight() + p;
      }

      var hBuff = this._shape === "Circle" ? typeof this._shapeConfig.r === "function" ? this._shapeConfig.r({
        tick: true
      }) : this._shapeConfig.r : this._shape === "Rect" ? typeof this._shapeConfig[height] === "function" ? this._shapeConfig[height]({
        tick: true
      }) : this._shapeConfig[height] : this._tickSize,
          wBuff = tickGet({
        tick: true
      });
      if (typeof hBuff === "function") hBuff = max(ticks.map(hBuff));
      if (this._shape === "Rect") hBuff /= 2;
      if (typeof wBuff === "function") wBuff = max(ticks.map(wBuff));
      if (this._shape !== "Circle") wBuff /= 2;
      /**
       * Calculates the space each label would take up, given
       * the provided this._space size.
       */

      var textData = labels.map(function (d, i) {
        var fF = _this3._shapeConfig.labelConfig.fontFamily(d, i),
            fS = _this3._shapeConfig.labelConfig.fontSize(d, i),
            position = _this3._getPosition(d);

        var lineHeight = _this3._shapeConfig.lineHeight ? _this3._shapeConfig.lineHeight(d, i) : fS * 1.4;
        return {
          d: d,
          i: i,
          fF: fF,
          fS: fS,
          lineHeight: lineHeight,
          position: position
        };
      });
      /**
       * Calculates the text wrapping and size of a given textData object.
       * @param {Object} datum
       */

      function calculateLabelSize(datum) {
        var d = datum.d,
            i = datum.i,
            fF = datum.fF,
            fS = datum.fS,
            rotate = datum.rotate,
            space = datum.space;
        var h = rotate ? "width" : "height",
            w = rotate ? "height" : "width";
        var wrap = textWrap().fontFamily(fF).fontSize(fS).lineHeight(this._shapeConfig.lineHeight ? this._shapeConfig.lineHeight(d, i) : undefined)[w](horizontal ? space : min([this._maxSize, this._width]) - hBuff - p - this._margin.left - this._margin.right)[h](horizontal ? min([this._maxSize, this._height]) - hBuff - p - this._margin.top - this._margin.bottom : space);
        var res = wrap(tickFormat(d));
        res.lines = res.lines.filter(function (d) {
          return d !== "";
        });
        res.width = res.lines.length ? Math.ceil(max(res.widths)) + fS / 4 : 0;
        if (res.width % 2) res.width++;
        res.height = res.lines.length ? Math.ceil(res.lines.length * wrap.lineHeight()) + fS / 4 : 0;
        if (res.height % 2) res.height++;
        return res;
      }

      textData = textData.map(function (datum) {
        datum.rotate = _this3._labelRotation;
        datum.space = calculateSpace.bind(_this3)(datum);
        var res = calculateLabelSize.bind(_this3)(datum);
        return Object.assign(res, datum);
      });
      this._rotateLabels = horizontal && this._labelRotation === undefined ? textData.some(function (d) {
        return d.truncated;
      }) : this._labelRotation;

      if (this._rotateLabels) {
        textData = textData.map(function (datum) {
          datum.rotate = true;
          var res = calculateLabelSize.bind(_this3)(datum);
          return Object.assign(datum, res);
        });
      }
      /**
       * "spillover" will contain the pixel spillover of the first and last label,
       * and then adjust the scale range accordingly.
       */


      var spillover = [0, 0];

      for (var index = 0; index < 2; index++) {
        var datum = textData[index ? textData.length - 1 : 0];
        if (!datum) break;
        var _height = datum.height,
            position = datum.position,
            rotate = datum.rotate,
            _width = datum.width;
        var compPosition = index ? rangeOuter[1] : rangeOuter[0];
        var halfSpace = (rotate || !horizontal ? _height : _width) / 2;
        var spill = index ? position + halfSpace - compPosition : position - halfSpace - compPosition;
        spillover[index] = spill;
      }

      var first = range[0];
      var last = range[range.length - 1];
      var newRange = [first - spillover[0], last - spillover[1]];

      if (this._range) {
        if (this._range[0] !== undefined) newRange[0] = this._range[0];
        if (this._range[this._range.length - 1] !== undefined) newRange[1] = this._range[this._range.length - 1];
      }

      if (newRange[0] !== first || newRange[1] !== last) {
        setScale.bind(this)(newRange);
        textData = labels.map(function (d, i) {
          var fF = _this3._shapeConfig.labelConfig.fontFamily(d, i),
              fS = _this3._shapeConfig.labelConfig.fontSize(d, i),
              position = _this3._getPosition(d);

          var lineHeight = _this3._shapeConfig.lineHeight ? _this3._shapeConfig.lineHeight(d, i) : fS * 1.4;
          return {
            d: d,
            i: i,
            fF: fF,
            fS: fS,
            lineHeight: lineHeight,
            position: position
          };
        });
        textData = textData.map(function (datum) {
          datum.rotate = _this3._rotateLabels;
          datum.space = calculateSpace.bind(_this3)(datum);
          var res = calculateLabelSize.bind(_this3)(datum);
          return Object.assign(res, datum);
        });
      }

      var labelHeight = max(textData, function (t) {
        return t.height;
      }) || 0;
      this._rotateLabels = horizontal && this._labelRotation === undefined ? textData.some(function (datum) {
        var i = datum.i,
            height = datum.height,
            position = datum.position,
            truncated = datum.truncated;
        var prev = textData[i - 1];
        return truncated || i && prev.position + prev.height / 2 > position - height / 2;
      }) : this._labelRotation;

      if (this._rotateLabels) {
        var offset = 0;
        textData = textData.map(function (datum) {
          datum.space = calculateSpace.bind(_this3)(datum, 2);
          var res = calculateLabelSize.bind(_this3)(datum);
          datum = Object.assign(datum, res);
          var prev = textData[datum.i - 1];

          if (!prev) {
            offset = 1;
          } else if (prev.position + prev.height / 2 > datum.position) {
            if (offset) {
              datum.offset = prev.width;
              offset = 0;
            } else offset = 1;
          }

          return datum;
        });
      }

      var globalOffset = this._labelOffset ? max(textData, function (d) {
        return d.offset || 0;
      }) : 0;
      textData.forEach(function (datum) {
        return datum.offset = datum.offset ? globalOffset : 0;
      });
      var tBuff = this._shape === "Line" ? 0 : hBuff;
      var bounds = this._outerBounds = (_this$_outerBounds = {}, _defineProperty(_this$_outerBounds, height, (max(textData, function (t) {
        return Math.ceil(t[t.rotate || !horizontal ? "width" : "height"] + t.offset);
      }) || 0) + (textData.length ? p : 0)), _defineProperty(_this$_outerBounds, width, rangeOuter[rangeOuter.length - 1] - rangeOuter[0]), _defineProperty(_this$_outerBounds, x, rangeOuter[0]), _this$_outerBounds);
      margin[this._orient] += hBuff;
      margin[opposite] = this._gridSize !== undefined ? max([this._gridSize, tBuff]) : this["_".concat(height)] - margin[this._orient] - bounds[height] - p;
      bounds[height] += margin[opposite] + margin[this._orient];
      bounds[y] = this._align === "start" ? this._padding : this._align === "end" ? this["_".concat(height)] - bounds[height] - this._padding : this["_".concat(height)] / 2 - bounds[height] / 2;
      var group = elem("g#d3plus-Axis-".concat(this._uuid), {
        parent: parent
      });
      this._group = group;
      var grid = elem("g.grid", {
        parent: group
      }).selectAll("line").data((this._gridSize !== 0 ? this._grid || this._scale === "log" && !this._gridLog ? labels : ticks : []).map(function (d) {
        return {
          id: d
        };
      }), function (d) {
        return d.id;
      });
      grid.exit().transition(t).attr("opacity", 0).call(this._gridPosition.bind(this)).remove();
      grid.enter().append("line").attr("opacity", 0).attr("clip-path", "url(#".concat(clipId, ")")).call(this._gridPosition.bind(this), true).merge(grid).transition(t).attr("opacity", 1).call(this._gridPosition.bind(this));
      var labelOnly = labels.filter(function (d, i) {
        return textData[i].lines.length && !ticks.includes(d);
      });
      var rotated = textData.some(function (d) {
        return d.rotate;
      });
      var tickData = ticks.concat(labelOnly).map(function (d) {
        var _tickConfig;

        var data = textData.find(function (td) {
          return td.d === d;
        });

        var xPos = _this3._getPosition(d);

        var space = data ? data.space : 0;
        var lines = data ? data.lines.length : 1;
        var lineHeight = data ? data.lineHeight : 1;
        var labelOffset = data && _this3._labelOffset ? data.offset : 0;
        var labelWidth = horizontal ? space : bounds.width - margin[_this3._position.opposite] - hBuff - margin[_this3._orient] + p;
        var offset = margin[opposite],
            size = (hBuff + labelOffset) * (flip ? -1 : 1),
            yPos = flip ? bounds[y] + bounds[height] - offset : bounds[y] + offset;
        var tickConfig = (_tickConfig = {
          id: d,
          labelBounds: rotated && data ? {
            x: -data.width / 2 + data.fS / 4,
            y: _this3._orient === "bottom" ? size + p + (data.width - lineHeight * lines) / 2 : size - p * 2 - (data.width + lineHeight * lines) / 2,
            width: data.width,
            height: data.height
          } : {
            x: horizontal ? -space / 2 : _this3._orient === "left" ? -labelWidth - p + size : size + p,
            y: horizontal ? _this3._orient === "bottom" ? size + p : size - p - labelHeight : -space / 2,
            width: horizontal ? space : labelWidth,
            height: horizontal ? labelHeight : space
          },
          rotate: data ? data.rotate : false,
          size: labels.includes(d) ? size : 0,
          text: labels.includes(d) ? tickFormat(d) : false,
          tick: ticks.includes(d)
        }, _defineProperty(_tickConfig, x, xPos + (_this3._scale === "band" ? _this3._d3Scale.bandwidth() / 2 : 0)), _defineProperty(_tickConfig, y, yPos), _tickConfig);
        return tickConfig;
      });

      if (this._shape === "Line") {
        tickData = tickData.concat(tickData.map(function (d) {
          var dupe = Object.assign({}, d);
          dupe[y] += d.size;
          return dupe;
        }));
      }

      new shapes[this._shape]().data(tickData).duration(this._duration).labelConfig({
        ellipsis: function ellipsis(d) {
          return d && d.length ? "".concat(d, "...") : "";
        },
        rotate: function rotate(d) {
          return d.rotate ? -90 : 0;
        }
      }).select(elem("g.ticks", {
        parent: group
      }).node()).config(this._shapeConfig).render();
      var bar = group.selectAll("line.bar").data([null]);
      bar.enter().append("line").attr("class", "bar").attr("opacity", 0).call(this._barPosition.bind(this)).merge(bar).transition(t).attr("opacity", 1).call(this._barPosition.bind(this));

      this._titleClass.data(this._title ? [{
        text: this._title
      }] : []).duration(this._duration).height(margin[this._orient]).rotate(this._orient === "left" ? -90 : this._orient === "right" ? 90 : 0).select(elem("g.d3plus-Axis-title", {
        parent: group
      }).node()).text(function (d) {
        return d.text;
      }).verticalAlign("middle").width(range[range.length - 1] - range[0]).x(horizontal ? range[0] : this._orient === "left" ? margin.left / 2 - (range[range.length - 1] - range[0]) / 2 + p : bounds.x + bounds.width - margin.right / 2 - (range[range.length - 1] - range[0]) / 2).y(horizontal ? this._orient === "bottom" ? bounds.y + bounds.height - margin.bottom - p : bounds.y : range[0] + (range[range.length - 1] - range[0]) / 2 - margin[this._orient] / 2).config(this._titleConfig).render();

      this._lastScale = this._getPosition.bind(this);
      if (callback) setTimeout(callback, this._duration + 100);
      return this;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the horizontal alignment to the specified value and returns the current class instance.
        @param {String} [*value* = "center"] Supports `"left"` and `"center"` and `"right"`.
        @chainable
    */

  }, {
    key: "align",
    value: function align(_) {
      return arguments.length ? (this._align = _, this) : this._align;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the axis line style and returns the current class instance.
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "barConfig",
    value: function barConfig(_) {
      return arguments.length ? (this._barConfig = Object.assign(this._barConfig, _), this) : this._barConfig;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the scale domain of the axis and returns the current class instance.
        @param {Array} [*value* = [0, 10]]
        @chainable
    */

  }, {
    key: "domain",
    value: function domain(_) {
      return arguments.length ? (this._domain = _, this) : this._domain;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the transition duration of the axis and returns the current class instance.
        @param {Number} [*value* = 600]
        @chainable
    */

  }, {
    key: "duration",
    value: function duration(_) {
      return arguments.length ? (this._duration = _, this) : this._duration;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the grid values of the axis and returns the current class instance.
        @param {Array} [*value*]
        @chainable
    */

  }, {
    key: "grid",
    value: function grid(_) {
      return arguments.length ? (this._grid = _, this) : this._grid;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the grid config of the axis and returns the current class instance.
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "gridConfig",
    value: function gridConfig(_) {
      return arguments.length ? (this._gridConfig = Object.assign(this._gridConfig, _), this) : this._gridConfig;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the grid behavior of the axis when scale is logarithmic and returns the current class instance.
        @param {Boolean} [*value* = false]
        @chainable
    */

  }, {
    key: "gridLog",
    value: function gridLog(_) {
      return arguments.length ? (this._gridLog = _, this) : this._gridLog;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the grid size of the axis and returns the current class instance.
        @param {Number} [*value* = undefined]
        @chainable
    */

  }, {
    key: "gridSize",
    value: function gridSize(_) {
      return arguments.length ? (this._gridSize = _, this) : this._gridSize;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the overall height of the axis and returns the current class instance.
        @param {Number} [*value* = 100]
        @chainable
    */

  }, {
    key: "height",
    value: function height(_) {
      return arguments.length ? (this._height = _, this) : this._height;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the visible tick labels of the axis and returns the current class instance.
        @param {Array} [*value*]
        @chainable
    */

  }, {
    key: "labels",
    value: function labels(_) {
      return arguments.length ? (this._labels = _, this) : this._labels;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets whether offsets will be used to position some labels further away from the axis in order to allow space for the text.
        @param {Boolean} [*value* = true]
        @chainable
     */

  }, {
    key: "labelOffset",
    value: function labelOffset(_) {
      return arguments.length ? (this._labelOffset = _, this) : this._labelOffset;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets whether whether horizontal axis labels are rotated -90 degrees.
        @param {Boolean}
        @chainable
     */

  }, {
    key: "labelRotation",
    value: function labelRotation(_) {
      return arguments.length ? (this._labelRotation = _, this) : this._labelRotation;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the maximum size allowed for the space that contains the axis tick labels and title.
        @param {Number}
        @chainable
     */

  }, {
    key: "maxSize",
    value: function maxSize(_) {
      return arguments.length ? (this._maxSize = _, this) : this._maxSize;
    }
    /**
        @memberof Axis
        @desc If *orient* is specified, sets the orientation of the shape and returns the current class instance. If *orient* is not specified, returns the current orientation.
        @param {String} [*orient* = "bottom"] Supports `"top"`, `"right"`, `"bottom"`, and `"left"` orientations.
        @chainable
    */

  }, {
    key: "orient",
    value: function orient(_) {
      if (arguments.length) {
        var horizontal = ["top", "bottom"].includes(_),
            opps = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        };
        this._position = {
          horizontal: horizontal,
          width: horizontal ? "width" : "height",
          height: horizontal ? "height" : "width",
          x: horizontal ? "x" : "y",
          y: horizontal ? "y" : "x",
          opposite: opps[_]
        };
        return this._orient = _, this;
      }

      return this._orient;
    }
    /**
        @memberof Axis
        @desc If called after the elements have been drawn to DOM, will returns the outer bounds of the axis content.
        @example
    {"width": 180, "height": 24, "x": 10, "y": 20}
    */

  }, {
    key: "outerBounds",
    value: function outerBounds() {
      return this._outerBounds;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the padding between each tick label to the specified number and returns the current class instance.
        @param {Number} [*value* = 10]
        @chainable
    */

  }, {
    key: "padding",
    value: function padding(_) {
      return arguments.length ? (this._padding = _, this) : this._padding;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the inner padding of band scale to the specified number and returns the current class instance.
        @param {Number} [*value* = 0.1]
        @chainable
    */

  }, {
    key: "paddingInner",
    value: function paddingInner(_) {
      return arguments.length ? (this._paddingInner = _, this) : this._paddingInner;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the outer padding of band scales to the specified number and returns the current class instance.
        @param {Number} [*value* = 0.1]
        @chainable
    */

  }, {
    key: "paddingOuter",
    value: function paddingOuter(_) {
      return arguments.length ? (this._paddingOuter = _, this) : this._paddingOuter;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the scale range (in pixels) of the axis and returns the current class instance. The given array must have 2 values, but one may be `undefined` to allow the default behavior for that value.
        @param {Array} [*value*]
        @chainable
    */

  }, {
    key: "range",
    value: function range(_) {
      return arguments.length ? (this._range = _, this) : this._range;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the scale of the axis and returns the current class instance.
        @param {String} [*value* = "linear"]
        @chainable
    */

  }, {
    key: "scale",
    value: function scale(_) {
      return arguments.length ? (this._scale = _, this) : this._scale;
    }
    /**
        @memberof Axis
        @desc Sets the "padding" property of the scale, often used in point scales.
        @param {Number} [*value* = 0.5]
        @chainable
    */

  }, {
    key: "scalePadding",
    value: function scalePadding(_) {
      return arguments.length ? (this._scalePadding = _, this) : this._scalePadding;
    }
    /**
        @memberof Axis
        @desc If *selector* is specified, sets the SVG container element to the specified d3 selector or DOM element and returns the current class instance. If *selector* is not specified, returns the current SVG container element.
        @param {String|HTMLElement} [*selector* = d3.select("body").append("svg")]
        @chainable
    */

  }, {
    key: "select",
    value: function select(_) {
      return arguments.length ? (this._select = _select(_), this) : this._select;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the tick shape constructor and returns the current class instance.
        @param {String} [*value* = "Line"]
        @chainable
    */

  }, {
    key: "shape",
    value: function shape(_) {
      return arguments.length ? (this._shape = _, this) : this._shape;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the tick style of the axis and returns the current class instance.
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "shapeConfig",
    value: function shapeConfig(_) {
      return arguments.length ? (this._shapeConfig = assign(this._shapeConfig, _), this) : this._shapeConfig;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the tick formatter and returns the current class instance.
        @param {Function} [*value*]
        @chainable
    */

  }, {
    key: "tickFormat",
    value: function tickFormat(_) {
      return arguments.length ? (this._tickFormat = _, this) : this._tickFormat;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the tick values of the axis and returns the current class instance.
        @param {Array} [*value*]
        @chainable
    */

  }, {
    key: "ticks",
    value: function ticks(_) {
      return arguments.length ? (this._ticks = _, this) : this._ticks;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the tick size of the axis and returns the current class instance.
        @param {Number} [*value* = 5]
        @chainable
    */

  }, {
    key: "tickSize",
    value: function tickSize(_) {
      return arguments.length ? (this._tickSize = _, this) : this._tickSize;
    }
    /**
        @memberof Axis
        @desc Sets the tick specifier for the [tickFormat](https://github.com/d3/d3-scale#continuous_tickFormat) function. If this method is called without any arguments, the default tick specifier is returned.
        @param {String} [*value* = undefined]
        @chainable
    */

  }, {
    key: "tickSpecifier",
    value: function tickSpecifier(_) {
      return arguments.length ? (this._tickSpecifier = _, this) : this._tickSpecifier;
    }
    /**
        @memberof Axis
        @desc Sets the behavior of the abbreviations when you are using linear scale. This method accepts two options: "normal" (uses formatAbbreviate to determinate the abbreviation) and "smallest" (uses suffix from the smallest tick as reference in every tick).
        @param {String} [*value* = "normal"]
        @chainable
    */

  }, {
    key: "tickSuffix",
    value: function tickSuffix(_) {
      return arguments.length ? (this._tickSuffix = _, this) : this._tickSuffix;
    }
    /**
        @memberof Axis
        @desc Defines a custom locale object to be used in time scale. This object must include the following properties: dateTime, date, time, periods, days, shortDays, months, shortMonths. For more information, you can revise [d3p.d3-time-format](https://github.com/d3/d3-time-format/blob/master/README.md#timeFormatLocale).
        @param {Object} [*value* = undefined]
        @chainable
    */

  }, {
    key: "timeLocale",
    value: function timeLocale(_) {
      return arguments.length ? (this._timeLocale = _, this) : this._timeLocale;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the title of the axis and returns the current class instance.
        @param {String} [*value*]
        @chainable
    */

  }, {
    key: "title",
    value: function title(_) {
      return arguments.length ? (this._title = _, this) : this._title;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the title configuration of the axis and returns the current class instance.
        @param {Object} [*value*]
        @chainable
    */

  }, {
    key: "titleConfig",
    value: function titleConfig(_) {
      return arguments.length ? (this._titleConfig = Object.assign(this._titleConfig, _), this) : this._titleConfig;
    }
    /**
        @memberof Axis
        @desc If *value* is specified, sets the overall width of the axis and returns the current class instance.
        @param {Number} [*value* = 400]
        @chainable
    */

  }, {
    key: "width",
    value: function width(_) {
      return arguments.length ? (this._width = _, this) : this._width;
    }
  }]);

  return Axis;
}(BaseClass);

export { Axis as default };